<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NYT Crossword</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --cell-size: 40px;
  --black: #000;
  --white: #fff;
  --highlight-word: #a7d8ff;
  --highlight-cell: #ffda00;
  --border: #888;
  --clue-hover: #dce8f0;
  --clue-active: #a7d8ff;
  --error: #ff4444;
  --checked: #2a6dd4;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: #f5f5f5;
  color: #222;
  min-height: 100vh;
}

/* ─── Calendar View ──────────────────────────────────────────── */
.calendar-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 16px;
  background: var(--white);
  border-bottom: 2px solid #ddd;
  flex-wrap: wrap;
}

.calendar-nav h1 {
  font-size: 1.3rem;
  font-weight: 700;
  margin-right: 12px;
}

.calendar-nav button, .calendar-nav select {
  padding: 6px 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.calendar-nav button:hover:not(:disabled) { background: #eee; }
.calendar-nav button:disabled { opacity: 0.4; cursor: default; }
.calendar-nav select { font-size: 0.85rem; }

.calendar-day-headers {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  max-width: 600px;
  margin: 12px auto 0;
  padding: 0 12px;
}
.calendar-day-headers span {
  text-align: center;
  font-size: 0.75rem;
  font-weight: 700;
  color: #888;
  text-transform: uppercase;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  max-width: 600px;
  margin: 6px auto 24px;
  padding: 0 12px;
}

.cal-day {
  aspect-ratio: 1;
  border-radius: 6px;
  border: 1.5px solid #ddd;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: transform 0.15s, box-shadow 0.15s;
  background: var(--white);
  display: flex;
  flex-direction: column;
  align-items: center;
}
.cal-day:hover:not(.empty) { transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.15); }
.cal-day.empty { background: transparent; border-color: transparent; cursor: default; }
.cal-day.no-puzzle { background: #fafafa; border-color: #eee; cursor: default; }
.cal-day.no-puzzle:hover { transform: none; box-shadow: none; }
.cal-day.today { border-color: #2a6dd4; border-width: 2.5px; }

.cal-day .day-number {
  font-size: 0.65rem;
  font-weight: 600;
  color: #555;
  margin-top: 2px;
  z-index: 1;
}
.cal-day.no-puzzle .day-number { color: #bbb; }

.cal-day canvas {
  image-rendering: pixelated;
  width: calc(100% - 6px);
  flex: 1;
  margin: 2px 3px 3px;
}

.star-overlay {
  display: none;
  position: absolute;
  inset: 0;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  pointer-events: none;
  text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.cal-day.complete .star-overlay { display: flex; }

/* ─── Puzzle View ────────────────────────────────────────────── */
#puzzle-view { display: none; }

.puzzle-header {
  text-align: center;
  padding: 16px;
  background: var(--white);
  border-bottom: 2px solid #ddd;
}
.puzzle-header .back-btn {
  position: absolute;
  left: 16px;
  top: 50%;
  transform: translateY(-50%);
  padding: 6px 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.puzzle-header .back-btn:hover { background: #eee; }
.puzzle-header { position: relative; }
.puzzle-header h1 { font-size: 1.3rem; font-weight: 700; }
.puzzle-header .meta { font-size: 0.85rem; color: #666; margin-top: 4px; }

.toolbar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  padding: 10px;
  background: var(--white);
  border-bottom: 1px solid #ddd;
  flex-wrap: wrap;
}
.toolbar button {
  padding: 6px 16px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.toolbar button:hover { background: #eee; }
.toolbar button.active { background: #2a6dd4; color: var(--white); border-color: #2a6dd4; }

.presence-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 6px 10px;
  background: #fafafa;
  border-bottom: 1px solid #eee;
  min-height: 28px;
  font-size: 0.78rem;
}
.presence-user {
  display: flex;
  align-items: center;
  gap: 4px;
}
.presence-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
}

.current-clue-bar {
  text-align: center;
  padding: 8px 16px;
  background: var(--highlight-word);
  font-size: 0.95rem;
  font-weight: 500;
  min-height: 36px;
}

.app {
  display: flex;
  justify-content: center;
  gap: 24px;
  padding: 16px;
  max-width: 1200px;
  margin: 0 auto;
}

/* Grid */
.grid-container { flex-shrink: 0; }

.grid {
  display: grid;
  border: 2px solid var(--black);
  user-select: none;
  cursor: pointer;
  touch-action: manipulation;
}

.cell {
  position: relative;
  width: var(--cell-size);
  height: var(--cell-size);
  border: 0.5px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: calc(var(--cell-size) * 0.5);
  font-weight: 600;
  background: var(--white);
  transition: background 0.1s;
}

.cell.black {
  background: var(--black);
  border-color: var(--black);
}

.cell .number {
  position: absolute;
  top: 1px;
  left: 2px;
  font-size: calc(var(--cell-size) * 0.25);
  font-weight: 500;
  line-height: 1;
  color: #333;
}

.cell .letter {
  margin-top: 4px;
  text-transform: uppercase;
}

.cell.highlight-word { background: var(--highlight-word); }
.cell.highlight-cell { background: var(--highlight-cell); }
.cell.error .letter { color: var(--error); }
.cell.checked .letter { color: var(--checked); }

/* Clue Panel */
.clue-panel {
  flex: 1;
  max-width: 380px;
  overflow-y: auto;
  background: var(--white);
  border: 1px solid #ddd;
  border-radius: 6px;
}

.clue-section h2 {
  position: sticky;
  top: 0;
  background: #e8ecf0;
  padding: 8px 12px;
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border-bottom: 1px solid #ddd;
  z-index: 1;
}

.clue-item {
  padding: 6px 12px;
  font-size: 0.85rem;
  cursor: pointer;
  display: flex;
  gap: 8px;
  border-bottom: 1px solid #f0f0f0;
  transition: background 0.1s;
}
.clue-item:hover { background: var(--clue-hover); }
.clue-item.active { background: var(--clue-active); }
.clue-item .clue-num { font-weight: 700; min-width: 24px; }
.clue-item .clue-text { flex: 1; }

/* Congratulations overlay */
.congrats-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.congrats-overlay.show { display: flex; }
.congrats-box {
  background: var(--white);
  padding: 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}
.congrats-box h2 { font-size: 1.8rem; margin-bottom: 8px; }
.congrats-box p { color: #666; margin-bottom: 20px; }
.congrats-box button {
  padding: 10px 28px;
  background: #2a6dd4;
  color: var(--white);
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
}

/* Hidden input for mobile keyboard */
.mobile-input {
  position: absolute;
  opacity: 0;
  width: 1px;
  height: 1px;
  top: -9999px;
  left: -9999px;
}

/* Mobile */
@media (max-width: 780px) {
  .calendar-nav { padding: 10px; gap: 6px; }
  .calendar-nav h1 { font-size: 1rem; margin-right: 6px; }
  .calendar-nav button, .calendar-nav select { padding: 5px 8px; font-size: 0.78rem; }

  .calendar-day-headers, .calendar-grid { max-width: 100%; padding: 0 6px; gap: 4px; }
  .cal-day .day-number { font-size: 0.55rem; }
  .star-overlay { font-size: 1.1rem; }

  .puzzle-header { padding: 10px; }
  .puzzle-header h1 { font-size: 1.1rem; }
  .puzzle-header .meta { font-size: 0.75rem; }
  .puzzle-header .back-btn { left: 6px; padding: 5px 8px; font-size: 0.78rem; }

  .toolbar { gap: 6px; padding: 8px; }
  .toolbar button { padding: 5px 10px; font-size: 0.78rem; }

  .current-clue-bar { font-size: 0.85rem; padding: 6px 10px; }

  .app { flex-direction: column; align-items: center; padding: 4px; gap: 8px; }
  .grid-container { width: 100%; display: flex; justify-content: center; }
  .clue-panel { max-width: 100%; max-height: 250px; width: 100%; }
}
</style>
</head>
<body>

<!-- ─── Calendar View ────────────────────────────────────────── -->
<div id="calendar-view">
  <div class="calendar-nav">
    <h1>NYT Crossword</h1>
    <button id="cal-prev">&lt;</button>
    <select id="cal-month"></select>
    <select id="cal-year"></select>
    <button id="cal-next">&gt;</button>
    <button id="cal-today">TODAY</button>
  </div>
  <div class="calendar-day-headers">
    <span>S</span><span>M</span><span>T</span><span>W</span><span>T</span><span>F</span><span>S</span>
  </div>
  <div class="calendar-grid" id="calendar-grid"></div>
</div>

<!-- ─── Puzzle View ──────────────────────────────────────────── -->
<div id="puzzle-view">
  <div class="puzzle-header">
    <button class="back-btn" id="btn-back">&larr; Calendar</button>
    <h1 id="puzzle-title">The New York Times Crossword</h1>
    <div class="meta" id="puzzle-meta"></div>
  </div>

  <div class="toolbar">
    <button id="btn-check">Auto-Check</button>
    <button id="btn-clear">Clear Puzzle</button>
    <button id="btn-reveal">Reveal Puzzle</button>
  </div>

  <div class="presence-bar" id="presence-bar"></div>

  <div class="current-clue-bar" id="current-clue-bar">&nbsp;</div>

  <div class="app">
    <div class="grid-container">
      <div class="grid" id="grid" tabindex="0"></div>
      <input type="text" id="mobile-input" class="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="characters" spellcheck="false">
    </div>
    <div class="clue-panel" id="clue-panel"></div>
  </div>
</div>

<div class="congrats-overlay" id="congrats">
  <div class="congrats-box">
    <h2>Congratulations!</h2>
    <p id="congrats-msg">You solved the crossword!</p>
    <button onclick="document.getElementById('congrats').classList.remove('show')">Close</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
// ─── User identity ──────────────────────────────────────────────
const USER_ID = localStorage.getItem('crossword-user-id') || (() => {
  const id = crypto.randomUUID();
  localStorage.setItem('crossword-user-id', id);
  return id;
})();

// ─── Socket.IO client ──────────────────────────────────────────
const socket = io({ query: { userId: USER_ID } });

socket.on('connect', () => {
  if (currentDate) socket.emit('join-puzzle', currentDate);
});

// ─── Puzzle state ──────────────────────────────────────────────
let PUZZLE = null;
let ROWS = 0, COLS = 0;
let userGrid = [];
let checkedCells = [];
let selectedRow = 0, selectedCol = 0;
let direction = 'across';
let autoCheck = false;
let solved = false;
let currentDate = null;

// ─── Remote user presence ──────────────────────────────────────
let myColor = '#90EE90';
const remoteUsers = new Map(); // socketId → {userId, color, row, col, direction}
let lastCursorKey = '';

// ─── DOM refs ──────────────────────────────────────────────────
const calendarView = document.getElementById('calendar-view');
const puzzleView = document.getElementById('puzzle-view');
const calendarGridEl = document.getElementById('calendar-grid');
const gridEl = document.getElementById('grid');
const cluePanelEl = document.getElementById('clue-panel');
const clueBarEl = document.getElementById('current-clue-bar');
const congratsEl = document.getElementById('congrats');
const titleEl = document.getElementById('puzzle-title');
const metaEl = document.getElementById('puzzle-meta');
const presenceBarEl = document.getElementById('presence-bar');
const btnCheck = document.getElementById('btn-check');
const btnClear = document.getElementById('btn-clear');
const btnReveal = document.getElementById('btn-reveal');
const btnBack = document.getElementById('btn-back');

// ─── Calendar state ────────────────────────────────────────────
const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
const MONTH_NAMES = ['January','February','March','April','May','June','July','August','September','October','November','December'];

let calendarYear, calendarMonth; // calendarMonth is 0-indexed
const calendarData = new Map(); // date → {date, rows, cols, cells, filledCount, totalWhite, isComplete}

function todayET() {
  return new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
}

function initCalendarNav() {
  const monthSel = document.getElementById('cal-month');
  const yearSel = document.getElementById('cal-year');

  for (let m = 0; m < 12; m++) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = MONTH_NAMES[m];
    monthSel.appendChild(opt);
  }

  const thisYear = new Date().getFullYear();
  for (let y = thisYear - 5; y <= thisYear + 1; y++) {
    const opt = document.createElement('option');
    opt.value = y;
    opt.textContent = y;
    yearSel.appendChild(opt);
  }

  // Default to current month
  const now = new Date();
  calendarYear = now.getFullYear();
  calendarMonth = now.getMonth();
  monthSel.value = calendarMonth;
  yearSel.value = calendarYear;

  monthSel.addEventListener('change', () => {
    calendarMonth = parseInt(monthSel.value);
    fetchAndRenderCalendar();
  });
  yearSel.addEventListener('change', () => {
    calendarYear = parseInt(yearSel.value);
    fetchAndRenderCalendar();
  });

  document.getElementById('cal-prev').addEventListener('click', () => {
    calendarMonth--;
    if (calendarMonth < 0) { calendarMonth = 11; calendarYear--; }
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
  document.getElementById('cal-next').addEventListener('click', () => {
    calendarMonth++;
    if (calendarMonth > 11) { calendarMonth = 0; calendarYear++; }
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
  document.getElementById('cal-today').addEventListener('click', () => {
    const now = new Date();
    calendarYear = now.getFullYear();
    calendarMonth = now.getMonth();
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
}

function syncCalendarSelects() {
  document.getElementById('cal-month').value = calendarMonth;
  document.getElementById('cal-year').value = calendarYear;
  // Enable/disable today button
  const now = new Date();
  const isCurrent = calendarYear === now.getFullYear() && calendarMonth === now.getMonth();
  document.getElementById('cal-today').disabled = isCurrent;
}

async function fetchAndRenderCalendar() {
  const ym = `${calendarYear}-${String(calendarMonth + 1).padStart(2, '0')}`;
  try {
    const res = await fetch(`/api/calendar/${ym}`);
    const data = await res.json();
    // Clear old month data from map, add new
    for (const [key] of calendarData) {
      if (key.startsWith(ym)) calendarData.delete(key);
    }
    for (const item of data) {
      calendarData.set(item.date, item);
    }
  } catch (e) {
    // Silently ignore fetch errors
  }
  renderCalendar();
  syncCalendarSelects();
}

function renderCalendar() {
  calendarGridEl.innerHTML = '';

  const today = todayET();
  const firstDay = new Date(calendarYear, calendarMonth, 1).getDay();
  const daysInMonth = new Date(calendarYear, calendarMonth + 1, 0).getDate();

  // Empty cells before first day
  for (let i = 0; i < firstDay; i++) {
    const empty = document.createElement('div');
    empty.className = 'cal-day empty';
    calendarGridEl.appendChild(empty);
  }

  for (let day = 1; day <= daysInMonth; day++) {
    const dateStr = `${calendarYear}-${String(calendarMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const info = calendarData.get(dateStr);

    const dayEl = document.createElement('div');
    dayEl.className = 'cal-day';
    dayEl.dataset.date = dateStr;

    if (dateStr === today) dayEl.classList.add('today');

    const numEl = document.createElement('span');
    numEl.className = 'day-number';
    numEl.textContent = day;
    dayEl.appendChild(numEl);

    if (info) {
      if (info.isComplete) dayEl.classList.add('complete');

      const canvas = document.createElement('canvas');
      canvas.width = info.cols;
      canvas.height = info.rows;
      drawThumbnail(canvas, info);
      dayEl.appendChild(canvas);

      const star = document.createElement('div');
      star.className = 'star-overlay';
      star.textContent = '\u2B50';
      dayEl.appendChild(star);

      dayEl.addEventListener('click', () => showPuzzle(dateStr));
    } else {
      dayEl.classList.add('no-puzzle');
    }

    calendarGridEl.appendChild(dayEl);
  }
}

function drawThumbnail(canvas, info) {
  const ctx = canvas.getContext('2d');
  const { rows, cols, cells, filledCount, totalWhite, isComplete } = info;
  const hasProgress = filledCount > 0;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const val = cells[r * cols + c];
      if (val === 0) {
        // Black cell
        ctx.fillStyle = '#4a4a4a';
      } else if (isComplete) {
        // Complete puzzle
        ctx.fillStyle = val === 2 ? '#2a5599' : '#4a7abf';
      } else if (hasProgress) {
        // In progress
        ctx.fillStyle = val === 2 ? '#5b9bd5' : '#ffffff';
      } else {
        // No progress — gray palette
        ctx.fillStyle = val === 1 ? '#c8c8c8' : '#c8c8c8';
      }
      ctx.fillRect(c, r, 1, 1);
    }
  }
}

// ─── View management ───────────────────────────────────────────
function showCalendar() {
  puzzleView.style.display = 'none';
  calendarView.style.display = 'block';
  document.title = 'NYT Crossword';

  if (currentDate) {
    socket.emit('leave-puzzle');
    currentDate = null;
  }
  PUZZLE = null;
  remoteUsers.clear();
  lastCursorKey = '';
  fetchAndRenderCalendar();
}

function showPuzzle(dateStr) {
  calendarView.style.display = 'none';
  puzzleView.style.display = 'block';
  loadPuzzle(dateStr);
}

// ─── Load a puzzle (async) ────────────────────────────────────
async function loadPuzzle(dateStr) {
  currentDate = dateStr;
  remoteUsers.clear();
  lastCursorKey = '';

  // Fetch puzzle data and shared state in parallel
  let data, stateData;
  try {
    const [puzzleRes, stateRes] = await Promise.all([
      fetch(`/api/puzzles/${dateStr}`),
      fetch(`/api/state/${dateStr}`),
    ]);
    if (!puzzleRes.ok) { alert('Puzzle not found'); showCalendar(); return; }
    data = await puzzleRes.json();
    stateData = await stateRes.json();
  } catch (e) {
    alert('Failed to load puzzle');
    showCalendar();
    return;
  }

  ROWS = data.dimensions.rows;
  COLS = data.dimensions.cols;

  const mapClues = (arr) => arr.map(c => ({
    n: c.number, clue: c.clue, answer: c.answer, row: c.row, col: c.col
  }));

  PUZZLE = {
    rows: ROWS,
    cols: COLS,
    grid: data.grid,
    cellNumbers: data.cellNumbers,
    clues: {
      across: mapClues(data.clues.across),
      down: mapClues(data.clues.down),
    },
  };

  // Reset state
  userGrid = Array.from({length: ROWS}, () => Array(COLS).fill(''));
  checkedCells = Array.from({length: ROWS}, () => Array(COLS).fill(false));
  autoCheck = false;
  solved = false;
  direction = 'across';
  btnCheck.classList.remove('active');
  congratsEl.classList.remove('show');

  // Apply shared state
  applySharedState(stateData.userGrid || {});

  // Update header
  const d = new Date(dateStr + 'T12:00:00');
  const dayName = DAYS[d.getDay()];
  const prettyDate = `${dayName}, ${MONTH_NAMES[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
  titleEl.textContent = data.title || 'The New York Times Crossword';
  metaEl.textContent = `${prettyDate} \u00B7 By ${data.author} \u00B7 Edited by ${data.editor}`;
  document.title = `Crossword \u2014 ${prettyDate}`;

  // Compute cell size based on grid dimensions
  const isMobile = window.innerWidth <= 780;
  const maxGridPx = isMobile
    ? window.innerWidth - 12
    : Math.min(window.innerWidth - 420, 650);
  const cellSize = Math.max(16, Math.min(40, Math.floor(maxGridPx / Math.max(ROWS, COLS))));
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');

  buildGrid();
  buildCluePanel();

  // Select first white cell
  selectedRow = 0; selectedCol = 0;
  for (let r = 0; r < ROWS; r++) {
    let found = false;
    for (let c = 0; c < COLS; c++) {
      if (!isBlack(r, c)) { selectedRow = r; selectedCol = c; found = true; break; }
    }
    if (found) break;
  }

  render();
  focusGrid();

  // Join puzzle room via Socket.IO
  socket.emit('join-puzzle', dateStr);
}

// ─── Collaboration helpers ────────────────────────────────────
function applySharedState(gridMap) {
  for (const [key, letter] of Object.entries(gridMap)) {
    const [r, c] = key.split(',').map(Number);
    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
      userGrid[r][c] = letter;
    }
  }
}

function sendCellUpdate(row, col, letter) {
  if (!currentDate) return;
  socket.emit('cell-update', { puzzleDate: currentDate, row, col, letter });
}

function broadcastCursor() {
  if (!currentDate) return;
  const key = `${selectedRow},${selectedCol},${direction}`;
  if (key === lastCursorKey) return;
  lastCursorKey = key;
  socket.emit('cursor-move', { puzzleDate: currentDate, row: selectedRow, col: selectedCol, direction });
}

// ─── Socket.IO event handlers for puzzle ──────────────────────
socket.on('room-state', ({ users, yourColor }) => {
  myColor = yourColor;
  remoteUsers.clear();
  for (const u of users) {
    remoteUsers.set(u.socketId, { userId: u.userId, color: u.color, row: u.row, col: u.col, direction: u.direction });
  }
  renderPresenceBar();
  if (PUZZLE) render();
});

socket.on('user-joined', ({ socketId, userId, color, row, col, direction: dir }) => {
  remoteUsers.set(socketId, { userId, color, row, col, direction: dir });
  renderPresenceBar();
  if (PUZZLE) render();
});

socket.on('user-left', ({ socketId }) => {
  remoteUsers.delete(socketId);
  renderPresenceBar();
  if (PUZZLE) render();
});

socket.on('cursor-moved', ({ socketId, userId, row, col, direction: dir }) => {
  const user = remoteUsers.get(socketId);
  if (user) {
    user.row = row;
    user.col = col;
    user.direction = dir;
  } else {
    remoteUsers.set(socketId, { userId, color: '#ccc', row, col, direction: dir });
  }
  if (PUZZLE) render();
});

socket.on('cell-updated', ({ row, col, letter }) => {
  if (!PUZZLE) return;
  if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
    userGrid[row][col] = letter;
    render();
    checkCompletion();
  }
});

socket.on('puzzle-cleared', () => {
  if (!PUZZLE) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      userGrid[r][c] = '';
      checkedCells[r][c] = false;
    }
  solved = false;
  congratsEl.classList.remove('show');
  render();
});

socket.on('puzzle-progress', (summary) => {
  calendarData.set(summary.date, summary);
  const dayEl = document.querySelector(`.cal-day[data-date="${summary.date}"]`);
  if (dayEl && !dayEl.classList.contains('no-puzzle')) {
    // Update complete class + star
    dayEl.classList.toggle('complete', summary.isComplete);
    // Redraw canvas
    const canvas = dayEl.querySelector('canvas');
    if (canvas) drawThumbnail(canvas, summary);
  }
});

function renderPresenceBar() {
  presenceBarEl.innerHTML = '';
  if (remoteUsers.size === 0) {
    presenceBarEl.style.display = 'none';
    return;
  }
  presenceBarEl.style.display = '';
  for (const [, user] of remoteUsers) {
    const el = document.createElement('span');
    el.className = 'presence-user';
    el.innerHTML = `<span class="presence-dot" style="background:${user.color}"></span>User`;
    presenceBarEl.appendChild(el);
  }
}

// ─── Helpers ───────────────────────────────────────────────────
function isBlack(r, c) {
  return PUZZLE.grid[r]?.[c] === '.';
}

function inBounds(r, c) {
  return r >= 0 && r < ROWS && c >= 0 && c < COLS;
}

function getClueForCell(r, c, dir) {
  const clues = dir === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  for (let i = clues.length - 1; i >= 0; i--) {
    const cl = clues[i];
    if (dir === 'across') {
      if (cl.row === r && cl.col <= c && cl.col + getWordLen(cl, 'across') > c) return cl;
    } else {
      if (cl.col === c && cl.row <= r && cl.row + getWordLen(cl, 'down') > r) return cl;
    }
  }
  return null;
}

function getWordLen(clue, dir) {
  if (clue.answer) return clue.answer.length;
  let len = 0;
  if (dir === 'across') {
    for (let c = clue.col; c < COLS && !isBlack(clue.row, c); c++) len++;
  } else {
    for (let r = clue.row; r < ROWS && !isBlack(r, clue.col); r++) len++;
  }
  return len;
}

function getWordCells(clue, dir) {
  const cells = [];
  const len = getWordLen(clue, dir);
  for (let i = 0; i < len; i++) {
    if (dir === 'across') cells.push([clue.row, clue.col + i]);
    else cells.push([clue.row + i, clue.col]);
  }
  return cells;
}

// ─── Build Grid ────────────────────────────────────────────────
let cellEls = [];

function buildGrid() {
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;
  gridEl.style.gridTemplateRows = `repeat(${ROWS}, var(--cell-size))`;

  cellEls = [];
  for (let r = 0; r < ROWS; r++) {
    cellEls[r] = [];
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell' + (isBlack(r, c) ? ' black' : '');

      const num = PUZZLE.cellNumbers[r][c];
      if (num > 0) {
        const numSpan = document.createElement('span');
        numSpan.className = 'number';
        numSpan.textContent = num;
        cell.appendChild(numSpan);
      }

      if (!isBlack(r, c)) {
        const letterSpan = document.createElement('span');
        letterSpan.className = 'letter';
        cell.appendChild(letterSpan);
      }

      cell.addEventListener('click', () => onCellClick(r, c));
      gridEl.appendChild(cell);
      cellEls[r][c] = cell;
    }
  }

  if (window.innerWidth > 780) {
    const gridH = ROWS * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 4;
    cluePanelEl.style.maxHeight = gridH + 'px';
  } else {
    cluePanelEl.style.maxHeight = '250px';
  }
}

// ─── Build Clue Panel ──────────────────────────────────────────
let clueItemEls = {};

function buildCluePanel() {
  cluePanelEl.innerHTML = '';
  clueItemEls = {};

  for (const dir of ['across', 'down']) {
    const section = document.createElement('div');
    section.className = 'clue-section';
    const h2 = document.createElement('h2');
    h2.textContent = dir.charAt(0).toUpperCase() + dir.slice(1);
    section.appendChild(h2);

    for (const clue of PUZZLE.clues[dir]) {
      const item = document.createElement('div');
      item.className = 'clue-item';

      const numSpan = document.createElement('span');
      numSpan.className = 'clue-num';
      numSpan.textContent = clue.n;
      item.appendChild(numSpan);

      const textSpan = document.createElement('span');
      textSpan.className = 'clue-text';
      textSpan.textContent = clue.clue;
      item.appendChild(textSpan);

      item.addEventListener('click', () => {
        direction = dir;
        selectedRow = clue.row;
        selectedCol = clue.col;
        render();
        focusGrid();
      });

      section.appendChild(item);
      clueItemEls[`${dir}-${clue.n}`] = item;
    }
    cluePanelEl.appendChild(section);
  }
}

// ─── Rendering ─────────────────────────────────────────────────
function render() {
  if (!PUZZLE) return;
  const currentClue = getClueForCell(selectedRow, selectedCol, direction);
  const wordCells = currentClue ? getWordCells(currentClue, direction) : [];
  const wordSet = new Set(wordCells.map(([r,c]) => `${r},${c}`));

  // Build remote user highlight maps
  const remoteCursorCells = new Map(); // "r,c" → color (selected cell)
  const remoteWordCells = new Map();   // "r,c" → color (word highlight)
  for (const [, user] of remoteUsers) {
    if (!PUZZLE) break;
    const rClue = getClueForCell(user.row, user.col, user.direction);
    if (rClue) {
      const rWordCells = getWordCells(rClue, user.direction);
      for (const [wr, wc] of rWordCells) {
        const key = `${wr},${wc}`;
        if (!remoteWordCells.has(key)) remoteWordCells.set(key, user.color);
      }
    }
    remoteCursorCells.set(`${user.row},${user.col}`, user.color);
  }

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const el = cellEls[r][c];
      if (isBlack(r, c)) continue;

      const key = `${r},${c}`;
      const isMyWord = wordSet.has(key);
      const isMyCell = r === selectedRow && c === selectedCol;

      el.classList.toggle('highlight-word', isMyWord);
      el.classList.toggle('highlight-cell', isMyCell);

      const letterEl = el.querySelector('.letter');
      if (letterEl) letterEl.textContent = userGrid[r][c];

      el.classList.toggle('checked', checkedCells[r][c]);
      if (autoCheck && userGrid[r][c] && !checkedCells[r][c]) {
        el.classList.toggle('error', userGrid[r][c] !== PUZZLE.grid[r][c]);
      } else {
        el.classList.remove('error');
      }

      // Remote cursor outline
      const remoteCursorColor = remoteCursorCells.get(key);
      if (remoteCursorColor && !isMyCell) {
        el.style.outline = `2.5px solid ${remoteCursorColor}`;
        el.style.outlineOffset = '-2.5px';
      } else {
        el.style.outline = '';
        el.style.outlineOffset = '';
      }

      // Remote word tint (only if not overlapping with current user's highlights)
      const remoteWordColor = remoteWordCells.get(key);
      if (remoteWordColor && !isMyWord && !isMyCell && !remoteCursorCells.has(key)) {
        // Parse hex color to rgba
        const hex = remoteWordColor.replace('#', '');
        const rr = parseInt(hex.substring(0, 2), 16);
        const gg = parseInt(hex.substring(2, 4), 16);
        const bb = parseInt(hex.substring(4, 6), 16);
        el.style.backgroundColor = `rgba(${rr},${gg},${bb},0.25)`;
      } else if (!isMyWord && !isMyCell) {
        el.style.backgroundColor = '';
      }
    }
  }

  if (currentClue) {
    const dirLabel = direction === 'across' ? 'A' : 'D';
    clueBarEl.textContent = `${currentClue.n}${dirLabel}: ${currentClue.clue}`;
  } else {
    clueBarEl.innerHTML = '&nbsp;';
  }

  for (const k in clueItemEls) clueItemEls[k].classList.remove('active');
  if (currentClue) {
    const k = `${direction}-${currentClue.n}`;
    if (clueItemEls[k]) {
      clueItemEls[k].classList.add('active');
      clueItemEls[k].scrollIntoView({block: 'nearest', behavior: 'smooth'});
    }
  }

  broadcastCursor();
}

// ─── Interaction ───────────────────────────────────────────────
function onCellClick(r, c) {
  if (isBlack(r, c)) return;
  if (r === selectedRow && c === selectedCol) {
    direction = direction === 'across' ? 'down' : 'across';
    if (!getClueForCell(r, c, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
  } else {
    selectedRow = r;
    selectedCol = c;
    if (!getClueForCell(r, c, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
  }
  render();
  focusGrid();
}

function advanceCursor() {
  if (direction === 'across') {
    let nc = selectedCol + 1;
    while (nc < COLS && isBlack(selectedRow, nc)) nc++;
    if (nc < COLS) selectedCol = nc;
  } else {
    let nr = selectedRow + 1;
    while (nr < ROWS && isBlack(nr, selectedCol)) nr++;
    if (nr < ROWS) selectedRow = nr;
  }
}

function retreatCursor() {
  if (direction === 'across') {
    let nc = selectedCol - 1;
    while (nc >= 0 && isBlack(selectedRow, nc)) nc--;
    if (nc >= 0) selectedCol = nc;
  } else {
    let nr = selectedRow - 1;
    while (nr >= 0 && isBlack(nr, selectedCol)) nr--;
    if (nr >= 0) selectedRow = nr;
  }
}

function moveToNextWord(forward) {
  const clues = direction === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  const currentClue = getClueForCell(selectedRow, selectedCol, direction);
  if (!currentClue) return;

  const idx = clues.findIndex(c => c.n === currentClue.n);
  let nextIdx;

  if (forward) {
    nextIdx = idx + 1;
    if (nextIdx >= clues.length) {
      direction = direction === 'across' ? 'down' : 'across';
      const other = direction === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
      selectedRow = other[0].row;
      selectedCol = other[0].col;
      render();
      return;
    }
  } else {
    nextIdx = idx - 1;
    if (nextIdx < 0) {
      direction = direction === 'across' ? 'down' : 'across';
      const other = direction === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
      selectedRow = other[other.length - 1].row;
      selectedCol = other[other.length - 1].col;
      render();
      return;
    }
  }

  selectedRow = clues[nextIdx].row;
  selectedCol = clues[nextIdx].col;
  render();
}

function moveArrow(dr, dc) {
  const newDir = dc !== 0 ? 'across' : 'down';

  if (newDir !== direction) {
    if (getClueForCell(selectedRow, selectedCol, newDir)) {
      direction = newDir;
      return;
    }
  }

  let r = selectedRow + dr;
  let c = selectedCol + dc;
  while (inBounds(r, c) && isBlack(r, c)) { r += dr; c += dc; }
  if (inBounds(r, c)) {
    selectedRow = r;
    selectedCol = c;
    direction = newDir;
  }
}

function checkCompletion() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (!isBlack(r, c) && userGrid[r][c] !== PUZZLE.grid[r][c]) return;
    }
  }
  solved = true;
  congratsEl.classList.add('show');
}

const mobileInput = document.getElementById('mobile-input');
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

function focusGrid() {
  if (isTouchDevice) {
    mobileInput.focus();
  } else {
    gridEl.focus();
  }
}

// ─── Mobile input handler ──────────────────────────────────────
mobileInput.addEventListener('input', (e) => {
  if (!PUZZLE || solved) return;
  const val = mobileInput.value;
  mobileInput.value = '';
  if (!val) return;
  const char = val.slice(-1);
  if (/^[a-zA-Z]$/.test(char)) {
    if (!checkedCells[selectedRow][selectedCol]) {
      const letter = char.toUpperCase();
      userGrid[selectedRow][selectedCol] = letter;
      sendCellUpdate(selectedRow, selectedCol, letter);
      if (autoCheck && letter === PUZZLE.grid[selectedRow][selectedCol]) {
        checkedCells[selectedRow][selectedCol] = true;
      }
    }
    render();
    advanceCursor();
    render();
    checkCompletion();
  }
});

mobileInput.addEventListener('keydown', (e) => {
  if (!PUZZLE || solved) return;
  if (e.key === 'Backspace') {
    e.preventDefault();
    if (checkedCells[selectedRow][selectedCol]) {
      retreatCursor();
    } else if (userGrid[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    } else {
      retreatCursor();
      if (!checkedCells[selectedRow][selectedCol]) {
        userGrid[selectedRow][selectedCol] = '';
        sendCellUpdate(selectedRow, selectedCol, '');
      }
    }
    render();
  }
});

// ─── Keyboard ──────────────────────────────────────────────────
gridEl.addEventListener('keydown', (e) => {
  if (!PUZZLE || solved) return;
  const key = e.key;

  if (key === 'ArrowLeft')       { e.preventDefault(); moveArrow(0, -1); render(); }
  else if (key === 'ArrowRight') { e.preventDefault(); moveArrow(0, 1); render(); }
  else if (key === 'ArrowUp')    { e.preventDefault(); moveArrow(-1, 0); render(); }
  else if (key === 'ArrowDown')  { e.preventDefault(); moveArrow(1, 0); render(); }
  else if (key === 'Tab') {
    e.preventDefault();
    moveToNextWord(!e.shiftKey);
  }
  else if (key === ' ') {
    e.preventDefault();
    direction = direction === 'across' ? 'down' : 'across';
    if (!getClueForCell(selectedRow, selectedCol, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
    render();
  }
  else if (key === 'Backspace') {
    e.preventDefault();
    if (checkedCells[selectedRow][selectedCol]) {
      retreatCursor();
    } else if (userGrid[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    } else {
      retreatCursor();
      if (!checkedCells[selectedRow][selectedCol]) {
        userGrid[selectedRow][selectedCol] = '';
        sendCellUpdate(selectedRow, selectedCol, '');
      }
    }
    render();
  }
  else if (key === 'Delete') {
    e.preventDefault();
    if (!checkedCells[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    }
    render();
  }
  else if (/^[a-zA-Z]$/.test(key)) {
    e.preventDefault();
    if (!checkedCells[selectedRow][selectedCol]) {
      const letter = key.toUpperCase();
      userGrid[selectedRow][selectedCol] = letter;
      sendCellUpdate(selectedRow, selectedCol, letter);
      if (autoCheck && userGrid[selectedRow][selectedCol] === PUZZLE.grid[selectedRow][selectedCol]) {
        checkedCells[selectedRow][selectedCol] = true;
      }
    }
    render();
    advanceCursor();
    render();
    checkCompletion();
  }
});

// ─── Toolbar ───────────────────────────────────────────────────
btnBack.addEventListener('click', () => showCalendar());

btnCheck.addEventListener('click', () => {
  if (!PUZZLE) return;
  autoCheck = !autoCheck;
  btnCheck.classList.toggle('active', autoCheck);
  if (autoCheck) {
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS; c++)
        if (userGrid[r][c] && userGrid[r][c] === PUZZLE.grid[r][c])
          checkedCells[r][c] = true;
  }
  render();
});

btnClear.addEventListener('click', () => {
  if (!PUZZLE || !confirm('Clear all entered letters?')) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      userGrid[r][c] = '';
      checkedCells[r][c] = false;
    }
  solved = false;
  congratsEl.classList.remove('show');
  if (currentDate) {
    socket.emit('clear-puzzle', { puzzleDate: currentDate });
  }
  render();
});

btnReveal.addEventListener('click', () => {
  if (!PUZZLE || !confirm('Reveal the entire puzzle?')) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (!isBlack(r, c)) {
        userGrid[r][c] = PUZZLE.grid[r][c];
        sendCellUpdate(r, c, PUZZLE.grid[r][c]);
      }
  render();
  checkCompletion();
});

// ─── Init ──────────────────────────────────────────────────────
initCalendarNav();
fetchAndRenderCalendar();
</script>
</body>
</html>
