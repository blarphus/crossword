<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>NYT Crossword</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --cell-size: 40px;
  --black: #000;
  --white: #fff;
  --highlight-word: #a7d8ff;
  --highlight-cell: #ffda00;
  --border: #888;
  --clue-hover: #dce8f0;
  --clue-active: #a7d8ff;
  --error: #ff4444;
  --checked: #2a6dd4;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: #f5f5f5;
  color: #222;
  min-height: 100vh;
}

/* ─── Calendar View ──────────────────────────────────────────── */
.calendar-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 16px;
  background: var(--white);
  border-bottom: 2px solid #ddd;
  flex-wrap: wrap;
}

.calendar-nav h1 {
  font-size: 1.3rem;
  font-weight: 700;
  margin-right: 12px;
}

.calendar-nav button, .calendar-nav select {
  padding: 6px 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.calendar-nav button:hover:not(:disabled) { background: #eee; }
.calendar-nav button:disabled { opacity: 0.4; cursor: default; }
.calendar-nav select { font-size: 0.85rem; }

.calendar-day-headers {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  max-width: 600px;
  margin: 12px auto 0;
  padding: 0 12px;
}
.calendar-day-headers span {
  text-align: center;
  font-size: 0.75rem;
  font-weight: 700;
  color: #888;
  text-transform: uppercase;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  max-width: 600px;
  margin: 6px auto 24px;
  padding: 0 12px;
}

.cal-day {
  aspect-ratio: 1;
  border-radius: 6px;
  border: 1.5px solid #ddd;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: transform 0.15s, box-shadow 0.15s;
  background: var(--white);
  display: flex;
  flex-direction: column;
  align-items: center;
}
.cal-day:hover:not(.empty) { transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.15); }
.cal-day.empty { background: transparent; border-color: transparent; cursor: default; }
.cal-day.no-puzzle { background: #fafafa; border-color: #eee; cursor: default; }
.cal-day.no-puzzle:hover { transform: none; box-shadow: none; }
.cal-day.today { border-color: #2a6dd4; border-width: 2.5px; }

.cal-day .day-number {
  font-size: 0.65rem;
  font-weight: 600;
  color: #555;
  margin-top: 2px;
  z-index: 1;
}
.cal-day.no-puzzle .day-number { color: #bbb; }

.cal-day canvas {
  image-rendering: pixelated;
  width: calc(100% - 6px);
  flex: 1;
  margin: 2px 3px 3px;
}

.star-overlay {
  display: none;
  position: absolute;
  inset: 0;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  pointer-events: none;
  text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.cal-day.complete .star-overlay { display: flex; }

.player-count-badge {
  position: absolute;
  top: 2px;
  right: 2px;
  background: #2a6dd4;
  color: #fff;
  font-size: 0.55rem;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  line-height: 1;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

/* ─── Puzzle View ────────────────────────────────────────────── */
#puzzle-view { display: none; flex-direction: column; }

.puzzle-header {
  text-align: center;
  padding: 16px;
  background: var(--white);
  border-bottom: 2px solid #ddd;
}
.puzzle-header .back-btn {
  position: absolute;
  left: 16px;
  top: 50%;
  transform: translateY(-50%);
  padding: 6px 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.puzzle-header .back-btn:hover { background: #eee; }
.puzzle-header { position: relative; }
.puzzle-header h1 { font-size: 1.3rem; font-weight: 700; }
.puzzle-header .meta { font-size: 0.85rem; color: #666; margin-top: 4px; }

.toolbar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  padding: 10px;
  background: var(--white);
  border-bottom: 1px solid #ddd;
  flex-wrap: wrap;
}
.toolbar button {
  padding: 6px 16px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.toolbar button:hover { background: #eee; }

.presence-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 6px 10px;
  background: #fafafa;
  border-bottom: 1px solid #eee;
  min-height: 28px;
  font-size: 0.78rem;
}
.presence-user {
  display: flex;
  align-items: center;
  gap: 4px;
}
.presence-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
}
.presence-pts {
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}
.solve-timer {
  font-variant-numeric: tabular-nums;
  font-weight: 600;
  color: #555;
  margin-left: auto;
  font-size: 0.82rem;
}

.current-clue-bar {
  display: flex;
  align-items: center;
  padding: 8px 8px;
  background: var(--highlight-word);
  font-size: 0.95rem;
  font-weight: 500;
  min-height: 36px;
}
#clue-bar-text { flex: 1; text-align: center; }
.clue-nav-btn {
  background: none; border: none; font-size: 1.5rem; cursor: pointer;
  padding: 0 8px; color: #333; font-weight: 700;
}

.app {
  display: flex;
  justify-content: center;
  gap: 24px;
  padding: 16px;
  max-width: 1200px;
  margin: 0 auto;
}

/* Grid */
.grid-container { flex-shrink: 0; }

.grid {
  display: grid;
  border: 2px solid var(--black);
  user-select: none;
  cursor: pointer;
  touch-action: manipulation;
}

.cell {
  position: relative;
  width: var(--cell-size);
  height: var(--cell-size);
  border: 0.5px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: calc(var(--cell-size) * 0.5);
  font-weight: 600;
  background: var(--white);
  transition: background 0.1s;
}

.cell.black {
  background: var(--black);
  border-color: var(--black);
}

.cell .number {
  position: absolute;
  top: 1px;
  left: 2px;
  font-size: calc(var(--cell-size) * 0.25);
  font-weight: 500;
  line-height: 1;
  color: #333;
}

.cell .letter {
  margin-top: 4px;
  text-transform: uppercase;
}

.cell.highlight-word { background: var(--highlight-word); }
.cell.highlight-cell { background: var(--highlight-cell); }
.cell.error .letter { color: var(--error); }
.cell.checked .letter { color: var(--checked); }

/* Shaded cells */
.cell.shaded { background: var(--shade-color, #c0c0c0); }
.cell.shaded.highlight-word { background: color-mix(in srgb, var(--shade-color, #c0c0c0) 50%, var(--highlight-word)); }
.cell.shaded.highlight-cell { background: color-mix(in srgb, var(--shade-color, #c0c0c0) 40%, var(--highlight-cell)); }

/* Circled cells */
.cell.circled::after {
  content: '';
  position: absolute;
  inset: 1px;
  border: 1.5px solid #333;
  border-radius: 50%;
  pointer-events: none;
}

/* Clue Panel */
.clue-panel {
  display: flex;
  gap: 0;
  flex: 1;
  max-width: 700px;
  background: var(--white);
  border: 1px solid #ddd;
  border-radius: 6px;
  overflow: hidden;
}

.clue-section {
  flex: 1;
  overflow-y: auto;
  min-width: 0;
}
.clue-section + .clue-section {
  border-left: 1px solid #ddd;
}

.clue-section h2 {
  position: sticky;
  top: 0;
  background: #e8ecf0;
  padding: 8px 12px;
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border-bottom: 1px solid #ddd;
  z-index: 1;
}

.clue-item {
  padding: 6px 12px;
  font-size: 0.85rem;
  cursor: pointer;
  display: flex;
  gap: 8px;
  border-bottom: 1px solid #f0f0f0;
  transition: background 0.1s;
  scroll-margin-top: 36px;
}
.clue-item:hover { background: var(--clue-hover); }
.clue-item.active { background: var(--clue-active); }
.clue-item.solved { opacity: 0.45; text-decoration: line-through; }
.clue-item.solved.active { opacity: 0.6; }
.clue-item .clue-num { font-weight: 700; min-width: 24px; }
.clue-item .clue-text { flex: 1; }

/* Congratulations overlay */
.congrats-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.congrats-overlay.show { display: flex; }
.congrats-box {
  background: var(--white);
  padding: 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}
.congrats-box h2 { font-size: 1.8rem; margin-bottom: 8px; }
.congrats-box p { color: #666; margin-bottom: 20px; }
.congrats-box button {
  padding: 10px 28px;
  background: #2a6dd4;
  color: var(--white);
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
}

/* Hidden input for mobile keyboard */
.mobile-input {
  position: absolute;
  opacity: 0;
  width: 1px;
  height: 1px;
  top: -9999px;
  left: -9999px;
}

/* Mobile keyboard */
.mobile-keyboard {
  display: none;
  background: #2c2c2e;
  padding: 6px 4px;
  position: fixed;
  bottom: 0; left: 0; right: 0;
  z-index: 50;
}
.kb-row { display: flex; justify-content: center; gap: 4px; margin-bottom: 4px; }
.kb-key {
  background: #5a5a5c;
  color: #fff;
  border: none;
  border-radius: 5px;
  font-size: 1.1rem;
  font-weight: 600;
  min-width: 32px;
  height: 42px;
  cursor: pointer;
  flex: 1;
  max-width: 38px;
}
.kb-key:active { background: #7a7a7c; }
.kb-more, .kb-backspace { flex: 1.4; max-width: 54px; font-size: 0.8rem; }

/* User badge in calendar nav */
.user-badge {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 4px 12px;
  border-radius: 20px;
  background: #eef3f8;
  font-size: 0.82rem;
  font-weight: 600;
  color: #333;
  cursor: pointer;
  transition: background 0.15s;
  margin-right: 4px;
}
.user-badge:hover { background: #dce8f0; }
.user-badge:empty { display: none; }
.user-badge-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

/* Name prompt modal */
.name-modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
.name-modal-overlay.show { display: flex; }
.name-modal {
  background: var(--white);
  padding: 36px 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  max-width: 340px;
  width: 90%;
}
.name-modal h2 { font-size: 1.4rem; margin-bottom: 6px; }
.name-modal p { color: #666; font-size: 0.9rem; margin-bottom: 18px; }
.name-modal input {
  width: 100%;
  padding: 10px 14px;
  border: 2px solid #ccc;
  border-radius: 6px;
  font-size: 1rem;
  margin-bottom: 14px;
  text-align: center;
  outline: none;
  transition: border-color 0.15s;
}
.name-modal input:focus { border-color: #2a6dd4; }
.name-modal button {
  padding: 10px 28px;
  background: #2a6dd4;
  color: var(--white);
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  width: 100%;
}
.name-modal button:disabled { opacity: 0.4; cursor: default; }

/* Mobile */
@media (max-width: 780px) {
  .calendar-nav { padding: 10px; gap: 6px; }
  .calendar-nav h1 { font-size: 1rem; margin-right: 6px; }
  .calendar-nav button, .calendar-nav select { padding: 5px 8px; font-size: 0.78rem; }
  .user-badge { font-size: 0.72rem; padding: 3px 8px; }

  .calendar-day-headers, .calendar-grid { max-width: 100%; padding: 0 6px; gap: 4px; }
  .cal-day .day-number { font-size: 0.55rem; }
  .star-overlay { font-size: 1.1rem; }

  /* Puzzle view fills screen as flex column */
  #puzzle-view { position: fixed; inset: 0; overflow: hidden; }

  .puzzle-header { padding: 6px 10px; flex-shrink: 0; }
  .puzzle-header h1 { font-size: 0.95rem; }
  .puzzle-header .meta { display: none; }
  .puzzle-header .back-btn { left: 6px; padding: 5px 8px; font-size: 0.78rem; }

  .toolbar { gap: 6px; padding: 4px 8px; flex-shrink: 0; }
  .toolbar button { padding: 4px 10px; font-size: 0.78rem; }

  .presence-bar { flex-shrink: 0; }

  .current-clue-bar { font-size: 0.85rem; padding: 6px 10px; background: #2b2d5e; color: #fff; flex-shrink: 0; }
  .clue-nav-btn { color: #fff; }

  /* Grid area fills remaining space */
  .app { flex: 1; min-height: 0; overflow: hidden; padding: 0; gap: 0; }
  .grid-container {
    width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
    overflow: hidden;
  }
  .grid { touch-action: none; }
  .clue-panel { display: none; }

  /* Keyboard at bottom of flex column */
  .mobile-keyboard { display: block; position: static; flex-shrink: 0; padding-bottom: env(safe-area-inset-bottom, 0px); }

}
</style>
</head>
<body>

<!-- ─── Calendar View ────────────────────────────────────────── -->
<div id="calendar-view">
  <div class="calendar-nav">
    <h1>NYT Crossword</h1>
    <span class="user-badge" id="user-badge" title="Click to change name"></span>
    <button id="cal-prev">&lt;</button>
    <select id="cal-month"></select>
    <select id="cal-year"></select>
    <button id="cal-next">&gt;</button>
    <button id="cal-today">TODAY</button>
  </div>
  <div class="calendar-day-headers">
    <span>S</span><span>M</span><span>T</span><span>W</span><span>T</span><span>F</span><span>S</span>
  </div>
  <div class="calendar-grid" id="calendar-grid"></div>
</div>

<!-- ─── Puzzle View ──────────────────────────────────────────── -->
<div id="puzzle-view">
  <div class="puzzle-header">
    <button class="back-btn" id="btn-back">&larr; Calendar</button>
    <h1 id="puzzle-title">The New York Times Crossword</h1>
    <div class="meta" id="puzzle-meta"></div>
  </div>

  <div class="toolbar">
    <button id="btn-clear">Clear Puzzle</button>
    <button id="btn-reveal">Reveal Puzzle</button>
    <span class="solve-timer" id="solve-timer">0:00</span>
  </div>

  <div class="presence-bar" id="presence-bar"></div>

  <div class="current-clue-bar" id="current-clue-bar">
    <button class="clue-nav-btn" id="clue-prev">&lsaquo;</button>
    <span id="clue-bar-text">&nbsp;</span>
    <button class="clue-nav-btn" id="clue-next">&rsaquo;</button>
  </div>

  <div class="app">
    <div class="grid-container">
      <div class="grid" id="grid" tabindex="0"></div>
      <input type="text" id="mobile-input" class="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="characters" spellcheck="false">
    </div>
    <div class="clue-panel" id="clue-panel"></div>
  </div>

  <div class="mobile-keyboard" id="mobile-keyboard"></div>
</div>

<!-- ─── Name Prompt Modal ────────────────────────────────────── -->
<div class="name-modal-overlay" id="name-modal">
  <div class="name-modal">
    <h2>Welcome!</h2>
    <p>Enter your name to start solving</p>
    <input type="text" id="name-input" placeholder="Your name" maxlength="20" autocomplete="off">
    <button id="name-submit" disabled>Start</button>
  </div>
</div>

<div class="congrats-overlay" id="congrats">
  <div class="congrats-box">
    <h2>Congratulations!</h2>
    <p id="congrats-msg">You solved the crossword!</p>
    <button onclick="document.getElementById('congrats').classList.remove('show')">Close</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
// ─── User identity (IP-based, server-managed) ──────────────────
let myName = '';
let myColor = '#90EE90';
let socket = null;

async function initIdentity() {
  try {
    const res = await fetch('/api/me');
    const data = await res.json();
    if (data.name) {
      myName = data.name;
      myColor = data.color;
      connectSocket();
      return;
    }
  } catch (e) {
    // Fallback: show modal anyway
  }
  // No name yet — show prompt
  showNameModal();
}

function showNameModal(isChange) {
  const modal = document.getElementById('name-modal');
  const input = document.getElementById('name-input');
  const btn = document.getElementById('name-submit');
  const heading = modal.querySelector('h2');
  const desc = modal.querySelector('p');

  if (isChange) {
    heading.textContent = 'Change Name';
    desc.textContent = 'Enter a new display name';
    btn.textContent = 'Save';
    input.value = myName;
    btn.disabled = false;
  } else {
    heading.textContent = 'Welcome!';
    desc.textContent = 'Enter your name to start solving';
    btn.textContent = 'Start';
    input.value = '';
    btn.disabled = true;
  }

  modal.classList.add('show');
  input.focus();
  input.select();

  // Clone and replace to remove old event listeners
  const newInput = input.cloneNode(true);
  input.parentNode.replaceChild(newInput, input);
  const newBtn = btn.cloneNode(true);
  btn.parentNode.replaceChild(newBtn, btn);

  newInput.addEventListener('input', () => {
    newBtn.disabled = !newInput.value.trim();
  });

  async function submit() {
    const name = newInput.value.trim();
    if (!name) return;
    newBtn.disabled = true;
    try {
      const res = await fetch('/api/me', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name }),
      });
      const data = await res.json();
      myName = data.name;
      myColor = data.color;
      modal.classList.remove('show');
      updateUserBadge();
      if (!isChange) {
        connectSocket();
      } else {
        // Reconnect socket with new name
        if (socket) {
          socket.disconnect();
          socket = null;
        }
        connectSocket();
      }
    } catch (e) {
      newBtn.disabled = false;
      alert('Failed to save name, please try again.');
    }
  }

  newBtn.addEventListener('click', submit);
  newInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submit();
  });
}

function updateUserBadge() {
  const badge = document.getElementById('user-badge');
  if (myName) {
    badge.innerHTML = `<span class="user-badge-dot" style="background:${myColor}"></span>${myName}`;
  } else {
    badge.innerHTML = '';
  }
}

// Click badge to change name
document.getElementById('user-badge').addEventListener('click', () => {
  showNameModal(true);
});

let appStarted = false;

function connectSocket() {
  socket = io({ query: { userId: myName } });

  socket.on('connect', () => {
    if (currentDate) socket.emit('join-puzzle', currentDate);
  });

  updateUserBadge();
  setupSocketHandlers();
  if (!appStarted) {
    appStarted = true;
    startApp();
  }
}

// ─── Puzzle state ──────────────────────────────────────────────
let PUZZLE = null;
let ROWS = 0, COLS = 0;
let userGrid = [];
let checkedCells = [];
let selectedRow = 0, selectedCol = 0;
let direction = 'across';
const autoCheck = true;
let solved = false;
let currentDate = null;

// Grid zoom state (mobile pinch-to-zoom)
let gridScale = 1, gridTx = 0, gridTy = 0;

// Solve timer state
let timerSeconds = 0;
let timerInterval = null;
const timerEl = document.getElementById('solve-timer');

function formatTimer(s) {
  const hrs = Math.floor(s / 3600);
  const mins = Math.floor((s % 3600) / 60);
  const secs = s % 60;
  if (hrs > 0) return `${hrs}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
  return `${mins}:${String(secs).padStart(2,'0')}`;
}

function updateTimerDisplay() {
  timerEl.textContent = formatTimer(timerSeconds);
}

function startTimerTick() {
  if (timerInterval) return;
  timerInterval = setInterval(() => {
    timerSeconds++;
    updateTimerDisplay();
  }, 1000);
}

function stopTimerTick() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

// ─── Remote user presence ──────────────────────────────────────
const remoteUsers = new Map(); // socketId → {userId, userName, color, row, col, direction}
const cellColors = new Map();  // "r,c" → color (who filled this cell)
const cellFillers = new Map(); // "r,c" → {userName, color} (who filled this cell)
const persistedPoints = new Map(); // userName → number (base points from DB, excludes word bonuses)
const roomCounts = new Map();  // puzzleDate → player count
let lastCursorKey = '';

// ─── DOM refs ──────────────────────────────────────────────────
const calendarView = document.getElementById('calendar-view');
const puzzleView = document.getElementById('puzzle-view');
const calendarGridEl = document.getElementById('calendar-grid');
const gridEl = document.getElementById('grid');
const cluePanelEl = document.getElementById('clue-panel');
const clueBarEl = document.getElementById('current-clue-bar');
const congratsEl = document.getElementById('congrats');
const titleEl = document.getElementById('puzzle-title');
const metaEl = document.getElementById('puzzle-meta');
const presenceBarEl = document.getElementById('presence-bar');
const btnClear = document.getElementById('btn-clear');
const btnReveal = document.getElementById('btn-reveal');
const btnBack = document.getElementById('btn-back');

// ─── Calendar state ────────────────────────────────────────────
const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
const MONTH_NAMES = ['January','February','March','April','May','June','July','August','September','October','November','December'];

let calendarYear, calendarMonth; // calendarMonth is 0-indexed
const calendarData = new Map(); // date → {date, rows, cols, cells, filledCount, totalWhite, isComplete}

function todayET() {
  return new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
}

function initCalendarNav() {
  const monthSel = document.getElementById('cal-month');
  const yearSel = document.getElementById('cal-year');

  for (let m = 0; m < 12; m++) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = MONTH_NAMES[m];
    monthSel.appendChild(opt);
  }

  const thisYear = new Date().getFullYear();
  for (let y = thisYear - 5; y <= thisYear + 1; y++) {
    const opt = document.createElement('option');
    opt.value = y;
    opt.textContent = y;
    yearSel.appendChild(opt);
  }

  // Restore saved month or default to current
  const savedYM = localStorage.getItem('crossword-calendar-month');
  const now = new Date();
  if (savedYM) {
    const [sy, sm] = savedYM.split('-').map(Number);
    calendarYear = sy;
    calendarMonth = sm;
  } else {
    calendarYear = now.getFullYear();
    calendarMonth = now.getMonth();
  }
  monthSel.value = calendarMonth;
  yearSel.value = calendarYear;

  monthSel.addEventListener('change', () => {
    calendarMonth = parseInt(monthSel.value);
    fetchAndRenderCalendar();
  });
  yearSel.addEventListener('change', () => {
    calendarYear = parseInt(yearSel.value);
    fetchAndRenderCalendar();
  });

  document.getElementById('cal-prev').addEventListener('click', () => {
    calendarMonth--;
    if (calendarMonth < 0) { calendarMonth = 11; calendarYear--; }
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
  document.getElementById('cal-next').addEventListener('click', () => {
    calendarMonth++;
    if (calendarMonth > 11) { calendarMonth = 0; calendarYear++; }
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
  document.getElementById('cal-today').addEventListener('click', () => {
    const now = new Date();
    calendarYear = now.getFullYear();
    calendarMonth = now.getMonth();
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
}

function syncCalendarSelects() {
  document.getElementById('cal-month').value = calendarMonth;
  document.getElementById('cal-year').value = calendarYear;
  // Enable/disable today button
  const now = new Date();
  const isCurrent = calendarYear === now.getFullYear() && calendarMonth === now.getMonth();
  document.getElementById('cal-today').disabled = isCurrent;
}

async function fetchAndRenderCalendar() {
  // Persist selected month
  localStorage.setItem('crossword-calendar-month', `${calendarYear}-${calendarMonth}`);
  const ym = `${calendarYear}-${String(calendarMonth + 1).padStart(2, '0')}`;
  try {
    const res = await fetch(`/api/calendar/${ym}`);
    const data = await res.json();
    // Clear old month data from map, add new
    for (const [key] of calendarData) {
      if (key.startsWith(ym)) calendarData.delete(key);
    }
    for (const item of data) {
      calendarData.set(item.date, item);
    }
  } catch (e) {
    // Silently ignore fetch errors
  }
  renderCalendar();
  syncCalendarSelects();
}

function renderCalendar() {
  calendarGridEl.innerHTML = '';

  const today = todayET();
  const firstDay = new Date(calendarYear, calendarMonth, 1).getDay();
  const daysInMonth = new Date(calendarYear, calendarMonth + 1, 0).getDate();

  // Empty cells before first day
  for (let i = 0; i < firstDay; i++) {
    const empty = document.createElement('div');
    empty.className = 'cal-day empty';
    calendarGridEl.appendChild(empty);
  }

  for (let day = 1; day <= daysInMonth; day++) {
    const dateStr = `${calendarYear}-${String(calendarMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const info = calendarData.get(dateStr);

    const dayEl = document.createElement('div');
    dayEl.className = 'cal-day';
    dayEl.dataset.date = dateStr;

    if (dateStr === today) dayEl.classList.add('today');

    const numEl = document.createElement('span');
    numEl.className = 'day-number';
    numEl.textContent = day;
    dayEl.appendChild(numEl);

    if (info) {
      if (info.isComplete) dayEl.classList.add('complete');

      const canvas = document.createElement('canvas');
      canvas.width = info.cols;
      canvas.height = info.rows;
      drawThumbnail(canvas, info);
      dayEl.appendChild(canvas);

      const star = document.createElement('div');
      star.className = 'star-overlay';
      star.textContent = '\u2B50';
      dayEl.appendChild(star);

      dayEl.addEventListener('click', () => showPuzzle(dateStr));
    } else {
      dayEl.classList.add('no-puzzle');
    }

    // Player count badge
    const playerCount = roomCounts.get(dateStr);
    if (playerCount > 0) {
      const badge = document.createElement('div');
      badge.className = 'player-count-badge';
      badge.textContent = playerCount;
      dayEl.appendChild(badge);
    }

    calendarGridEl.appendChild(dayEl);
  }
}

function drawThumbnail(canvas, info) {
  const ctx = canvas.getContext('2d');
  const { rows, cols, cells, filledCount, totalWhite, isComplete } = info;
  const hasProgress = filledCount > 0;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const val = cells[r * cols + c];
      if (val === 0) {
        // Black cell
        ctx.fillStyle = '#4a4a4a';
      } else if (isComplete) {
        // Complete puzzle
        ctx.fillStyle = val === 2 ? '#2a5599' : '#4a7abf';
      } else if (hasProgress) {
        // In progress
        ctx.fillStyle = val === 2 ? '#5b9bd5' : '#ffffff';
      } else {
        // No progress — gray palette
        ctx.fillStyle = val === 1 ? '#c8c8c8' : '#c8c8c8';
      }
      ctx.fillRect(c, r, 1, 1);
    }
  }
}

// ─── View management ───────────────────────────────────────────
function showCalendar() {
  puzzleView.style.display = 'none';
  calendarView.style.display = 'block';
  document.title = 'NYT Crossword';

  if (currentDate) {
    if (socket) socket.emit('leave-puzzle');
    currentDate = null;
  }
  stopTimerTick();
  timerSeconds = 0;
  updateTimerDisplay();
  localStorage.removeItem('crossword-current-puzzle');
  PUZZLE = null;
  remoteUsers.clear();
  lastCursorKey = '';
  fetchAndRenderCalendar();
}

function showPuzzle(dateStr) {
  calendarView.style.display = 'none';
  puzzleView.style.display = 'flex';
  loadPuzzle(dateStr);
}

// ─── Load a puzzle (async) ────────────────────────────────────
async function loadPuzzle(dateStr) {
  currentDate = dateStr;
  localStorage.setItem('crossword-current-puzzle', dateStr);
  remoteUsers.clear();
  cellColors.clear();
  cellFillers.clear();
  persistedPoints.clear();
  lastCursorKey = '';

  // Fetch puzzle data and shared state in parallel
  let data, stateData;
  try {
    const [puzzleRes, stateRes] = await Promise.all([
      fetch(`/api/puzzles/${dateStr}`),
      fetch(`/api/state/${dateStr}`),
    ]);
    if (!puzzleRes.ok) { alert('Puzzle not found'); showCalendar(); return; }
    data = await puzzleRes.json();
    stateData = await stateRes.json();
  } catch (e) {
    alert('Failed to load puzzle');
    showCalendar();
    return;
  }

  ROWS = data.dimensions.rows;
  COLS = data.dimensions.cols;

  const mapClues = (arr) => arr.map(c => ({
    n: c.number, clue: c.clue, answer: c.answer, row: c.row, col: c.col
  }));

  // Build circle and shade lookup sets
  const circleSet = new Set();
  if (data.circles) {
    for (const [r, c] of data.circles) circleSet.add(`${r},${c}`);
  }
  const shadeMap = new Map();
  if (data.shades) {
    for (const [r, c, color] of data.shades) shadeMap.set(`${r},${c}`, color);
  }

  PUZZLE = {
    rows: ROWS,
    cols: COLS,
    grid: data.grid,
    cellNumbers: data.cellNumbers,
    circles: circleSet,
    shades: shadeMap,
    clues: {
      across: mapClues(data.clues.across),
      down: mapClues(data.clues.down),
    },
  };

  // Reset state
  userGrid = Array.from({length: ROWS}, () => Array(COLS).fill(''));
  checkedCells = Array.from({length: ROWS}, () => Array(COLS).fill(false));
  solved = false;
  direction = 'across';
  congratsEl.classList.remove('show');

  // Apply shared state
  applySharedState(stateData.userGrid || {}, stateData.cellFillers || {}, stateData.points || {}, stateData.userColors || {});

  // Mark all correct letters as checked (auto-check is always on)
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (userGrid[r][c] && userGrid[r][c] === PUZZLE.grid[r][c])
        checkedCells[r][c] = true;

  // Update header
  const d = new Date(dateStr + 'T12:00:00');
  const dayName = DAYS[d.getDay()];
  const prettyDate = `${dayName}, ${MONTH_NAMES[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
  titleEl.textContent = data.title || 'The New York Times Crossword';
  metaEl.textContent = `${prettyDate} \u00B7 By ${data.author} \u00B7 Edited by ${data.editor}`;
  document.title = `Crossword \u2014 ${prettyDate}`;

  // Compute cell size based on grid dimensions
  const isMobile = window.innerWidth <= 780;
  let cellSize;
  if (isMobile) {
    const availW = window.innerWidth - 8;
    const availH = window.innerHeight - 260; // header + toolbar + clue bar + keyboard
    cellSize = Math.max(16, Math.min(40, Math.floor(Math.min(availW / COLS, availH / ROWS))));
  } else {
    const maxGridPx = Math.min(window.innerWidth - 420, 650);
    cellSize = Math.max(16, Math.min(40, Math.floor(maxGridPx / Math.max(ROWS, COLS))));
  }
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');

  buildGrid();
  buildCluePanel();

  // Select first white cell
  selectedRow = 0; selectedCol = 0;
  for (let r = 0; r < ROWS; r++) {
    let found = false;
    for (let c = 0; c < COLS; c++) {
      if (!isBlack(r, c)) { selectedRow = r; selectedCol = c; found = true; break; }
    }
    if (found) break;
  }

  render();
  focusGrid();

  // Join puzzle room via Socket.IO
  if (socket) socket.emit('join-puzzle', dateStr);
}

// ─── Collaboration helpers ────────────────────────────────────
function applySharedState(gridMap, fillersMap, pointsMap, userColorsMap) {
  for (const [key, letter] of Object.entries(gridMap)) {
    const [r, c] = key.split(',').map(Number);
    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
      userGrid[r][c] = letter;
    }
  }
  // Apply persisted cell fillers with real colors
  if (fillersMap) {
    for (const [key, name] of Object.entries(fillersMap)) {
      if (name) {
        const color = (userColorsMap && userColorsMap[name]) || (name === myName ? myColor : '#ccc');
        cellFillers.set(key, { userName: name, color });
        cellColors.set(key, color);
      }
    }
  }
  // Apply persisted base points
  if (pointsMap) {
    for (const [name, pts] of Object.entries(pointsMap)) {
      persistedPoints.set(name, pts);
    }
  }
}

function sendCellUpdate(row, col, letter) {
  if (!currentDate || !socket) return;
  const key = `${row},${col}`;
  if (letter) {
    cellColors.set(key, myColor);
    cellFillers.set(key, { userName: myName, color: myColor });
    // Immediate local point scoring
    if (PUZZLE) {
      const delta = (letter === PUZZLE.grid[row][col]) ? 1 : -1;
      persistedPoints.set(myName, (persistedPoints.get(myName) || 0) + delta);
    }
  } else {
    cellColors.delete(key);
    cellFillers.delete(key);
    // No point change on delete — penalties/rewards persist
  }
  socket.emit('cell-update', { puzzleDate: currentDate, row, col, letter });
}

function broadcastCursor() {
  if (!currentDate || !socket) return;
  const key = `${selectedRow},${selectedCol},${direction}`;
  if (key === lastCursorKey) return;
  lastCursorKey = key;
  socket.emit('cursor-move', { puzzleDate: currentDate, row: selectedRow, col: selectedCol, direction });
}

// ─── Socket.IO event handlers for puzzle ──────────────────────
function setupSocketHandlers() {
  socket.on('room-state', ({ users, yourColor, yourName }) => {
    myColor = yourColor;
    if (yourName) myName = yourName;
    remoteUsers.clear();
    for (const u of users) {
      remoteUsers.set(u.socketId, { userId: u.userId, userName: u.userName || 'User', color: u.color, row: u.row, col: u.col, direction: u.direction });
    }
    // Update filler colors from room users
    updateFillerColorsFromRoom();
    renderPresenceBar();
    if (PUZZLE) render();
  });

  socket.on('user-joined', ({ socketId, userId, userName: uName, color, row, col, direction: dir }) => {
    remoteUsers.set(socketId, { userId, userName: uName || 'User', color, row, col, direction: dir });
    renderPresenceBar();
    if (PUZZLE) render();
  });

  socket.on('user-left', ({ socketId }) => {
    remoteUsers.delete(socketId);
    renderPresenceBar();
    if (PUZZLE) render();
  });

  socket.on('cursor-moved', ({ socketId, userId, userName: uName, row, col, direction: dir }) => {
    const user = remoteUsers.get(socketId);
    if (user) {
      user.row = row;
      user.col = col;
      user.direction = dir;
    } else {
      remoteUsers.set(socketId, { userId, userName: uName || 'User', color: '#ccc', row, col, direction: dir });
    }
    if (PUZZLE) render();
  });

  socket.on('cell-updated', ({ row, col, letter, userId: remoteUserId, userName: remoteName, color: remoteColor, pointDelta }) => {
    if (!PUZZLE) return;
    if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
      userGrid[row][col] = letter;
      const key = `${row},${col}`;
      if (letter) {
        const color = remoteColor || findColorForUser(remoteUserId);
        cellColors.set(key, color);
        cellFillers.set(key, { userName: remoteName || 'User', color });
        if (autoCheck && letter === PUZZLE.grid[row][col]) {
          checkedCells[row][col] = true;
        }
      } else {
        cellColors.delete(key);
        cellFillers.delete(key);
      }
      // Apply remote point delta
      if (pointDelta && remoteName) {
        persistedPoints.set(remoteName, (persistedPoints.get(remoteName) || 0) + pointDelta);
      }
      render();
      checkCompletion();
    }
  });

  socket.on('timer-sync', ({ seconds }) => {
    timerSeconds = seconds;
    updateTimerDisplay();
    startTimerTick();
  });

  socket.on('puzzle-cleared', () => {
    if (!PUZZLE) return;
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS; c++) {
        userGrid[r][c] = '';
        checkedCells[r][c] = false;
      }
    cellColors.clear();
    cellFillers.clear();
    persistedPoints.clear();
    solved = false;
    congratsEl.classList.remove('show');
    render();
  });

  socket.on('room-count', ({ puzzleDate, count }) => {
    if (count > 0) {
      roomCounts.set(puzzleDate, count);
    } else {
      roomCounts.delete(puzzleDate);
    }
    const dayEl = document.querySelector(`.cal-day[data-date="${puzzleDate}"]`);
    if (dayEl) {
      let badge = dayEl.querySelector('.player-count-badge');
      if (count > 0) {
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'player-count-badge';
          dayEl.appendChild(badge);
        }
        badge.textContent = count;
      } else if (badge) {
        badge.remove();
      }
    }
  });

  socket.on('puzzle-progress', (summary) => {
    calendarData.set(summary.date, summary);
    const dayEl = document.querySelector(`.cal-day[data-date="${summary.date}"]`);
    if (dayEl && !dayEl.classList.contains('no-puzzle')) {
      dayEl.classList.toggle('complete', summary.isComplete);
      const canvas = dayEl.querySelector('canvas');
      if (canvas) drawThumbnail(canvas, summary);
    }
  });
}

function findColorForUser(userId) {
  for (const [, u] of remoteUsers) {
    if (u.userId === userId) return u.color;
  }
  return '#ccc';
}

function updateFillerColorsFromRoom() {
  // After getting room state, update filler colors for users we now know about
  const nameColorMap = new Map();
  nameColorMap.set(myName, myColor);
  for (const [, u] of remoteUsers) {
    nameColorMap.set(u.userName, u.color);
  }
  for (const [key, filler] of cellFillers) {
    const knownColor = nameColorMap.get(filler.userName);
    if (knownColor) {
      filler.color = knownColor;
      cellColors.set(key, knownColor);
    }
  }
}

function computeUserPoints() {
  if (!PUZZLE) return new Map();
  const points = new Map(); // userName → { color, pts }

  function ensure(name, color) {
    if (!points.has(name)) points.set(name, { color: color || '#ccc', pts: 0 });
    const p = points.get(name);
    if (color && color !== '#ccc') p.color = color;
    return p;
  }

  // Start from persisted base points (includes all historical +1/-1 from letter placements)
  for (const [name, pts] of persistedPoints) {
    ensure(name, null).pts = pts;
  }

  // Apply filler colors (so we know each user's color for display)
  for (const [, filler] of cellFillers) {
    ensure(filler.userName, filler.color);
  }

  // +5 for each fully correct word to every user who filled a cell in it
  for (const dir of ['across', 'down']) {
    for (const clue of PUZZLE.clues[dir]) {
      const cells = getWordCells(clue, dir);
      const allCorrect = cells.every(([r, c]) =>
        userGrid[r][c] && userGrid[r][c] === PUZZLE.grid[r][c]
      );
      if (!allCorrect) continue;
      const wordFillers = new Set();
      for (const [r, c] of cells) {
        const filler = cellFillers.get(`${r},${c}`);
        if (filler) wordFillers.add(filler.userName);
      }
      for (const name of wordFillers) {
        ensure(name, null).pts += 5;
      }
    }
  }

  return points;
}

function renderPresenceBar() {
  presenceBarEl.innerHTML = '';

  const points = computeUserPoints();

  // Build list: current user + online remote users
  const allUsers = [{ name: myName, color: myColor, label: myName || 'You' }];
  const seenNames = new Set([myName]);
  for (const [, user] of remoteUsers) {
    if (!seenNames.has(user.userName)) {
      allUsers.push({ name: user.userName, color: user.color, label: user.userName });
      seenNames.add(user.userName);
    }
  }
  // Include offline users who have points (from persisted fillers)
  for (const [name, data] of points) {
    if (!seenNames.has(name)) {
      allUsers.push({ name, color: data.color, label: name });
      seenNames.add(name);
    }
  }

  if (allUsers.length <= 1 && !points.has(myName)) {
    presenceBarEl.style.display = 'none';
    return;
  }
  presenceBarEl.style.display = '';

  for (const u of allUsers) {
    const data = points.get(u.name);
    const pts = data ? data.pts : 0;
    const el = document.createElement('span');
    el.className = 'presence-user';
    const ptsStr = pts !== 0 ? ` <span class="presence-pts">${pts > 0 ? '+' : ''}${pts}</span>` : '';
    el.innerHTML = `<span class="presence-dot" style="background:${u.color}"></span>${u.label}${ptsStr}`;
    presenceBarEl.appendChild(el);
  }
}

// ─── Helpers ───────────────────────────────────────────────────
function isBlack(r, c) {
  return PUZZLE.grid[r]?.[c] === '.';
}

function inBounds(r, c) {
  return r >= 0 && r < ROWS && c >= 0 && c < COLS;
}

function getClueForCell(r, c, dir) {
  const clues = dir === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  for (let i = clues.length - 1; i >= 0; i--) {
    const cl = clues[i];
    if (dir === 'across') {
      if (cl.row === r && cl.col <= c && cl.col + getWordLen(cl, 'across') > c) return cl;
    } else {
      if (cl.col === c && cl.row <= r && cl.row + getWordLen(cl, 'down') > r) return cl;
    }
  }
  return null;
}

function getWordLen(clue, dir) {
  if (clue.answer) return clue.answer.length;
  let len = 0;
  if (dir === 'across') {
    for (let c = clue.col; c < COLS && !isBlack(clue.row, c); c++) len++;
  } else {
    for (let r = clue.row; r < ROWS && !isBlack(r, clue.col); r++) len++;
  }
  return len;
}

function getWordCells(clue, dir) {
  const cells = [];
  const len = getWordLen(clue, dir);
  for (let i = 0; i < len; i++) {
    if (dir === 'across') cells.push([clue.row, clue.col + i]);
    else cells.push([clue.row + i, clue.col]);
  }
  return cells;
}

// ─── Build Grid ────────────────────────────────────────────────
let cellEls = [];

function buildGrid() {
  gridScale = 1; gridTx = 0; gridTy = 0;
  gridEl.style.transform = '';
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;
  gridEl.style.gridTemplateRows = `repeat(${ROWS}, var(--cell-size))`;

  cellEls = [];
  for (let r = 0; r < ROWS; r++) {
    cellEls[r] = [];
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell' + (isBlack(r, c) ? ' black' : '');

      const num = PUZZLE.cellNumbers[r][c];
      if (num > 0) {
        const numSpan = document.createElement('span');
        numSpan.className = 'number';
        numSpan.textContent = num;
        cell.appendChild(numSpan);
      }

      if (!isBlack(r, c)) {
        const letterSpan = document.createElement('span');
        letterSpan.className = 'letter';
        cell.appendChild(letterSpan);

        // Circle overlay
        const key = `${r},${c}`;
        if (PUZZLE.circles.has(key)) {
          cell.classList.add('circled');
        }

        // Shade background
        const shadeColor = PUZZLE.shades.get(key);
        if (shadeColor) {
          cell.classList.add('shaded');
          cell.style.setProperty('--shade-color', shadeColor);
        }
      }

      cell.addEventListener('click', () => onCellClick(r, c));
      gridEl.appendChild(cell);
      cellEls[r][c] = cell;
    }
  }

  if (window.innerWidth > 780) {
    const gridH = ROWS * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 4;
    cluePanelEl.style.maxHeight = gridH + 'px';
    for (const sec of cluePanelEl.querySelectorAll('.clue-section')) {
      sec.style.maxHeight = gridH + 'px';
    }
  } else {
    cluePanelEl.style.maxHeight = '300px';
  }
}

// ─── Build Clue Panel ──────────────────────────────────────────
let clueItemEls = {};

function buildCluePanel() {
  cluePanelEl.innerHTML = '';
  clueItemEls = {};

  for (const dir of ['across', 'down']) {
    const section = document.createElement('div');
    section.className = 'clue-section';
    const h2 = document.createElement('h2');
    h2.textContent = dir.charAt(0).toUpperCase() + dir.slice(1);
    section.appendChild(h2);

    for (const clue of PUZZLE.clues[dir]) {
      const item = document.createElement('div');
      item.className = 'clue-item';

      const numSpan = document.createElement('span');
      numSpan.className = 'clue-num';
      numSpan.textContent = clue.n;
      item.appendChild(numSpan);

      const textSpan = document.createElement('span');
      textSpan.className = 'clue-text';
      textSpan.textContent = clue.clue;
      item.appendChild(textSpan);

      item.addEventListener('click', () => {
        direction = dir;
        selectedRow = clue.row;
        selectedCol = clue.col;
        render();
        focusGrid();
      });

      section.appendChild(item);
      clueItemEls[`${dir}-${clue.n}`] = item;
    }
    cluePanelEl.appendChild(section);
  }
}

// ─── Color helpers ──────────────────────────────────────────────
function darkenColor(hex, amount) {
  // amount 0–1: 0 = no change, 1 = black
  hex = hex.replace('#', '');
  const r = Math.round(parseInt(hex.substring(0, 2), 16) * (1 - amount));
  const g = Math.round(parseInt(hex.substring(2, 4), 16) * (1 - amount));
  const b = Math.round(parseInt(hex.substring(4, 6), 16) * (1 - amount));
  return `rgb(${r},${g},${b})`;
}

// ─── Rendering ─────────────────────────────────────────────────
function render() {
  if (!PUZZLE) return;
  const currentClue = getClueForCell(selectedRow, selectedCol, direction);
  const wordCells = currentClue ? getWordCells(currentClue, direction) : [];
  const wordSet = new Set(wordCells.map(([r,c]) => `${r},${c}`));

  // Build remote user highlight maps
  const remoteCursorCells = new Map(); // "r,c" → color (selected cell)
  const remoteWordCells = new Map();   // "r,c" → color (word highlight)
  for (const [, user] of remoteUsers) {
    if (!PUZZLE) break;
    const rClue = getClueForCell(user.row, user.col, user.direction);
    if (rClue) {
      const rWordCells = getWordCells(rClue, user.direction);
      for (const [wr, wc] of rWordCells) {
        const key = `${wr},${wc}`;
        if (!remoteWordCells.has(key)) remoteWordCells.set(key, user.color);
      }
    }
    remoteCursorCells.set(`${user.row},${user.col}`, user.color);
  }

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const el = cellEls[r][c];
      if (isBlack(r, c)) continue;

      const key = `${r},${c}`;
      const isMyWord = wordSet.has(key);
      const isMyCell = r === selectedRow && c === selectedCol;

      el.classList.toggle('highlight-word', isMyWord);
      el.classList.toggle('highlight-cell', isMyCell);

      const letterEl = el.querySelector('.letter');
      if (letterEl) letterEl.textContent = userGrid[r][c];

      el.classList.toggle('checked', checkedCells[r][c]);
      if (autoCheck && userGrid[r][c] && !checkedCells[r][c]) {
        el.classList.toggle('error', userGrid[r][c] !== PUZZLE.grid[r][c]);
      } else {
        el.classList.remove('error');
      }

      // Remote cursor: fill with a darker shade of the user's color
      const remoteCursorColor = remoteCursorCells.get(key);
      if (remoteCursorColor && !isMyCell) {
        el.style.backgroundColor = darkenColor(remoteCursorColor, 0.55);
        el.style.outline = '';
        el.style.outlineOffset = '';
      } else if (!remoteCursorCells.has(key)) {
        el.style.outline = '';
        el.style.outlineOffset = '';
      }

      // Cell filler color: colored inset box-shadow showing who typed the letter
      const fillerColor = cellColors.get(key);
      if (fillerColor && userGrid[r][c]) {
        el.style.boxShadow = `inset 0 0 0 2px ${fillerColor}`;
      } else {
        el.style.boxShadow = '';
      }

      // Remote word tint (only if not overlapping with current user's highlights or cursor)
      const remoteWordColor = remoteWordCells.get(key);
      if (remoteWordColor && !isMyWord && !isMyCell && !remoteCursorCells.has(key)) {
        const hex = remoteWordColor.replace('#', '');
        const rr = parseInt(hex.substring(0, 2), 16);
        const gg = parseInt(hex.substring(2, 4), 16);
        const bb = parseInt(hex.substring(4, 6), 16);
        el.style.backgroundColor = `rgba(${rr},${gg},${bb},0.25)`;
      } else if (!isMyWord && !isMyCell && !remoteCursorCells.has(key)) {
        el.style.backgroundColor = '';
      }
    }
  }

  const clueBarTextEl = clueBarEl.querySelector('#clue-bar-text');
  if (currentClue) {
    const dirLabel = direction === 'across' ? 'A' : 'D';
    clueBarTextEl.textContent = `${currentClue.n}${dirLabel}: ${currentClue.clue}`;
  } else {
    clueBarTextEl.innerHTML = '&nbsp;';
  }

  for (const k in clueItemEls) {
    clueItemEls[k].classList.remove('active');
  }
  if (currentClue) {
    const k = `${direction}-${currentClue.n}`;
    if (clueItemEls[k]) {
      clueItemEls[k].classList.add('active');
      clueItemEls[k].scrollIntoView({block: 'nearest', behavior: 'smooth'});
    }
  }

  // Mark solved clues
  for (const dir of ['across', 'down']) {
    for (const clue of PUZZLE.clues[dir]) {
      const k = `${dir}-${clue.n}`;
      const el = clueItemEls[k];
      if (!el) continue;
      const wCells = getWordCells(clue, dir);
      const isSolved = wCells.length > 0 && wCells.every(([wr, wc]) =>
        userGrid[wr][wc] && userGrid[wr][wc] === PUZZLE.grid[wr][wc]
      );
      el.classList.toggle('solved', isSolved);
    }
  }

  // Update presence bar with live percentages
  renderPresenceBar();

  broadcastCursor();
}

// ─── Interaction ───────────────────────────────────────────────
function onCellClick(r, c) {
  if (isBlack(r, c)) return;
  if (r === selectedRow && c === selectedCol) {
    direction = direction === 'across' ? 'down' : 'across';
    if (!getClueForCell(r, c, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
  } else {
    selectedRow = r;
    selectedCol = c;
    if (!getClueForCell(r, c, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
  }
  render();
  focusGrid();
}

function advanceCursor() {
  if (direction === 'across') {
    let nc = selectedCol + 1;
    while (nc < COLS && isBlack(selectedRow, nc)) nc++;
    if (nc < COLS) selectedCol = nc;
  } else {
    let nr = selectedRow + 1;
    while (nr < ROWS && isBlack(nr, selectedCol)) nr++;
    if (nr < ROWS) selectedRow = nr;
  }
}

function retreatCursor() {
  if (direction === 'across') {
    let nc = selectedCol - 1;
    if (nc >= 0 && !isBlack(selectedRow, nc)) selectedCol = nc;
  } else {
    let nr = selectedRow - 1;
    if (nr >= 0 && !isBlack(nr, selectedCol)) selectedRow = nr;
  }
}

function moveToNextWord(forward) {
  const clues = direction === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  const currentClue = getClueForCell(selectedRow, selectedCol, direction);
  if (!currentClue) return;

  const idx = clues.findIndex(c => c.n === currentClue.n);
  let nextIdx;

  if (forward) {
    nextIdx = idx + 1;
    if (nextIdx >= clues.length) {
      direction = direction === 'across' ? 'down' : 'across';
      const other = direction === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
      selectedRow = other[0].row;
      selectedCol = other[0].col;
      render();
      return;
    }
  } else {
    nextIdx = idx - 1;
    if (nextIdx < 0) {
      direction = direction === 'across' ? 'down' : 'across';
      const other = direction === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
      selectedRow = other[other.length - 1].row;
      selectedCol = other[other.length - 1].col;
      render();
      return;
    }
  }

  selectedRow = clues[nextIdx].row;
  selectedCol = clues[nextIdx].col;
  render();
}

function moveArrow(dr, dc) {
  const newDir = dc !== 0 ? 'across' : 'down';

  if (newDir !== direction) {
    if (getClueForCell(selectedRow, selectedCol, newDir)) {
      direction = newDir;
      return;
    }
  }

  let r = selectedRow + dr;
  let c = selectedCol + dc;
  while (inBounds(r, c) && isBlack(r, c)) { r += dr; c += dc; }
  if (inBounds(r, c)) {
    selectedRow = r;
    selectedCol = c;
    direction = newDir;
  }
}

function checkCompletion() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (!isBlack(r, c) && userGrid[r][c] !== PUZZLE.grid[r][c]) return;
    }
  }
  solved = true;
  congratsEl.classList.add('show');
}

const mobileInput = document.getElementById('mobile-input');
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

function focusGrid() {
  if (isTouchDevice) {
    mobileInput.focus();
  } else {
    gridEl.focus();
  }
}

// ─── Mobile input handler ──────────────────────────────────────
mobileInput.addEventListener('input', (e) => {
  if (!PUZZLE || solved) return;
  const val = mobileInput.value;
  mobileInput.value = '';
  if (!val) return;
  const char = val.slice(-1);
  if (/^[a-zA-Z]$/.test(char)) {
    if (!checkedCells[selectedRow][selectedCol]) {
      const letter = char.toUpperCase();
      userGrid[selectedRow][selectedCol] = letter;
      sendCellUpdate(selectedRow, selectedCol, letter);
      if (autoCheck && letter === PUZZLE.grid[selectedRow][selectedCol]) {
        checkedCells[selectedRow][selectedCol] = true;
      }
    }
    render();
    advanceCursor();
    render();
    checkCompletion();
  }
});

mobileInput.addEventListener('keydown', (e) => {
  if (!PUZZLE || solved) return;
  if (e.key === 'Backspace') {
    e.preventDefault();
    if (checkedCells[selectedRow][selectedCol]) {
      retreatCursor();
    } else if (userGrid[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    } else {
      retreatCursor();
      if (!checkedCells[selectedRow][selectedCol]) {
        userGrid[selectedRow][selectedCol] = '';
        sendCellUpdate(selectedRow, selectedCol, '');
      }
    }
    render();
  }
});

// ─── Keyboard ──────────────────────────────────────────────────
gridEl.addEventListener('keydown', (e) => {
  if (!PUZZLE || solved) return;
  const key = e.key;

  if (key === 'ArrowLeft')       { e.preventDefault(); moveArrow(0, -1); render(); }
  else if (key === 'ArrowRight') { e.preventDefault(); moveArrow(0, 1); render(); }
  else if (key === 'ArrowUp')    { e.preventDefault(); moveArrow(-1, 0); render(); }
  else if (key === 'ArrowDown')  { e.preventDefault(); moveArrow(1, 0); render(); }
  else if (key === 'Tab') {
    e.preventDefault();
    moveToNextWord(!e.shiftKey);
  }
  else if (key === ' ') {
    e.preventDefault();
    direction = direction === 'across' ? 'down' : 'across';
    if (!getClueForCell(selectedRow, selectedCol, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
    render();
  }
  else if (key === 'Backspace') {
    e.preventDefault();
    if (checkedCells[selectedRow][selectedCol]) {
      retreatCursor();
    } else if (userGrid[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    } else {
      retreatCursor();
      if (!checkedCells[selectedRow][selectedCol]) {
        userGrid[selectedRow][selectedCol] = '';
        sendCellUpdate(selectedRow, selectedCol, '');
      }
    }
    render();
  }
  else if (key === 'Delete') {
    e.preventDefault();
    if (!checkedCells[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    }
    render();
  }
  else if (/^[a-zA-Z]$/.test(key)) {
    e.preventDefault();
    if (!checkedCells[selectedRow][selectedCol]) {
      const letter = key.toUpperCase();
      userGrid[selectedRow][selectedCol] = letter;
      sendCellUpdate(selectedRow, selectedCol, letter);
      if (autoCheck && userGrid[selectedRow][selectedCol] === PUZZLE.grid[selectedRow][selectedCol]) {
        checkedCells[selectedRow][selectedCol] = true;
      }
    }
    render();
    advanceCursor();
    render();
    checkCompletion();
  }
});

// ─── Toolbar ───────────────────────────────────────────────────
btnBack.addEventListener('click', () => showCalendar());

btnClear.addEventListener('click', () => {
  if (!PUZZLE || !confirm('Clear all entered letters?')) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      userGrid[r][c] = '';
      checkedCells[r][c] = false;
    }
  cellColors.clear();
  cellFillers.clear();
  persistedPoints.clear();
  solved = false;
  congratsEl.classList.remove('show');
  if (currentDate && socket) {
    socket.emit('clear-puzzle', { puzzleDate: currentDate });
  }
  render();
});

btnReveal.addEventListener('click', () => {
  if (!PUZZLE || !confirm('Reveal the entire puzzle?')) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (!isBlack(r, c)) {
        userGrid[r][c] = PUZZLE.grid[r][c];
        sendCellUpdate(r, c, PUZZLE.grid[r][c]);
      }
  render();
  checkCompletion();
});

// ─── Mobile keyboard ────────────────────────────────────────────
function initMobileKeyboard() {
  const kb = document.getElementById('mobile-keyboard');
  const rows = [
    ['Q','W','E','R','T','Y','U','I','O','P'],
    ['A','S','D','F','G','H','J','K','L'],
    ['MORE','Z','X','C','V','B','N','M','BACK'],
  ];

  rows.forEach(letters => {
    const rowEl = document.createElement('div');
    rowEl.className = 'kb-row';
    letters.forEach(l => {
      const btn = document.createElement('button');
      btn.className = 'kb-key';
      if (l === 'MORE') {
        btn.classList.add('kb-more');
        btn.textContent = 'More';
      } else if (l === 'BACK') {
        btn.classList.add('kb-backspace');
        btn.textContent = '\u232B';
      } else {
        btn.textContent = l;
      }
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (!PUZZLE || solved) return;
        if (l === 'MORE') return;
        if (l === 'BACK') {
          handleBackspace();
        } else {
          handleLetterInput(l);
        }
      });
      rowEl.appendChild(btn);
    });
    kb.appendChild(rowEl);
  });
}

function handleLetterInput(letter) {
  if (!checkedCells[selectedRow][selectedCol]) {
    userGrid[selectedRow][selectedCol] = letter;
    sendCellUpdate(selectedRow, selectedCol, letter);
    if (autoCheck && letter === PUZZLE.grid[selectedRow][selectedCol]) {
      checkedCells[selectedRow][selectedCol] = true;
    }
  }
  render();
  advanceCursor();
  render();
  checkCompletion();
}

function handleBackspace() {
  if (checkedCells[selectedRow][selectedCol]) {
    retreatCursor();
  } else if (userGrid[selectedRow][selectedCol]) {
    userGrid[selectedRow][selectedCol] = '';
    sendCellUpdate(selectedRow, selectedCol, '');
  } else {
    retreatCursor();
    if (!checkedCells[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    }
  }
  render();
}

const isMobileDevice = window.innerWidth <= 780;

// Override focusGrid to skip hidden input on mobile
const origFocusGrid = focusGrid;
focusGrid = function() {
  if (isMobileDevice) {
    // Don't focus the hidden input — custom keyboard handles input
    gridEl.focus();
  } else {
    origFocusGrid();
  }
};

// On mobile, prevent the hidden input from showing the system keyboard
if (isMobileDevice) {
  mobileInput.setAttribute('inputmode', 'none');
  mobileInput.setAttribute('readonly', 'true');
}

initMobileKeyboard();

// ─── Mobile grid pinch-to-zoom + pan ────────────────────────────
if (isMobileDevice) {
  const gc = document.querySelector('.grid-container');
  let pinchInitDist = 0, pinchInitScale = 1;
  let pinchInitCenter = {x: 0, y: 0};
  let pinchInitTx = 0, pinchInitTy = 0;
  let isPinching = false;
  let panStart = null, panStartTx = 0, panStartTy = 0, didPan = false;

  function applyGridTransform() {
    gridEl.style.transformOrigin = '0 0';
    gridEl.style.transform = `translate(${gridTx}px,${gridTy}px) scale(${gridScale})`;
  }

  function clampGridPos() {
    const cr = gc.getBoundingClientRect();
    const gw = gridEl.offsetWidth * gridScale;
    const gh = gridEl.offsetHeight * gridScale;
    if (gw <= cr.width) { gridTx = (cr.width - gw) / 2; }
    else { gridTx = Math.min(0, Math.max(cr.width - gw, gridTx)); }
    if (gh <= cr.height) { gridTy = (cr.height - gh) / 2; }
    else { gridTy = Math.min(0, Math.max(cr.height - gh, gridTy)); }
  }

  function pDist(t) {
    const dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function pCenter(t) {
    return { x: (t[0].clientX + t[1].clientX) / 2, y: (t[0].clientY + t[1].clientY) / 2 };
  }

  gc.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      e.preventDefault();
      isPinching = true;
      // Initialize transform from flex-centered position if needed
      if (gridScale === 1 && gridTx === 0 && gridTy === 0) {
        const gr = gridEl.getBoundingClientRect();
        const cr = gc.getBoundingClientRect();
        gridTx = gr.left - cr.left;
        gridTy = gr.top - cr.top;
        applyGridTransform();
      }
      pinchInitDist = pDist(e.touches);
      pinchInitScale = gridScale;
      pinchInitCenter = pCenter(e.touches);
      pinchInitTx = gridTx;
      pinchInitTy = gridTy;
      panStart = null;
    } else if (e.touches.length === 1 && gridScale > 1) {
      panStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      panStartTx = gridTx;
      panStartTy = gridTy;
      didPan = false;
    }
  }, { passive: false });

  gc.addEventListener('touchmove', e => {
    if (isPinching && e.touches.length === 2) {
      e.preventDefault();
      const nd = pDist(e.touches);
      const nc = pCenter(e.touches);
      const newScale = Math.max(1, Math.min(4, pinchInitScale * (nd / pinchInitDist)));
      // Zoom toward pinch center
      const rect = gc.getBoundingClientRect();
      const cx = pinchInitCenter.x - rect.left;
      const cy = pinchInitCenter.y - rect.top;
      const gx = (cx - pinchInitTx) / pinchInitScale;
      const gy = (cy - pinchInitTy) / pinchInitScale;
      gridTx = (nc.x - rect.left) - gx * newScale;
      gridTy = (nc.y - rect.top) - gy * newScale;
      gridScale = newScale;
      clampGridPos();
      applyGridTransform();
    } else if (e.touches.length === 1 && panStart && gridScale > 1) {
      const dx = e.touches[0].clientX - panStart.x;
      const dy = e.touches[0].clientY - panStart.y;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) didPan = true;
      if (didPan) {
        e.preventDefault();
        gridTx = panStartTx + dx;
        gridTy = panStartTy + dy;
        clampGridPos();
        applyGridTransform();
      }
    }
  }, { passive: false });

  gc.addEventListener('touchend', e => {
    if (e.touches.length < 2) {
      isPinching = false;
      if (gridScale < 1.05) {
        gridScale = 1; gridTx = 0; gridTy = 0;
        gridEl.style.transform = '';
      }
    }
    if (e.touches.length === 0) panStart = null;
  });

  // Suppress cell clicks after panning
  gc.addEventListener('click', e => {
    if (didPan) { e.stopPropagation(); e.preventDefault(); didPan = false; }
  }, true);

  // Prevent overscroll/bounce everywhere except grid container
  puzzleView.addEventListener('touchmove', e => {
    if (!e.target.closest('.grid-container')) e.preventDefault();
  }, { passive: false });
}

// ─── Clue bar navigation ────────────────────────────────────────
document.getElementById('clue-prev').addEventListener('click', () => {
  if (!PUZZLE) return;
  moveToNextWord(false);
  render();
  focusGrid();
});
document.getElementById('clue-next').addEventListener('click', () => {
  if (!PUZZLE) return;
  moveToNextWord(true);
  render();
  focusGrid();
});

// ─── Init ──────────────────────────────────────────────────────
function startApp() {
  const savedPuzzle = localStorage.getItem('crossword-current-puzzle');
  initCalendarNav();
  if (savedPuzzle) {
    showPuzzle(savedPuzzle);
  } else {
    fetchAndRenderCalendar();
  }
}

// Begin: check identity first, then connect socket, then start app
initIdentity();
</script>
</body>
</html>
