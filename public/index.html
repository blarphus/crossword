<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>NYT Crossword</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --cell-size: 40px;
  --black: #000;
  --white: #fff;
  --highlight-word: #a7d8ff;
  --highlight-cell: #ffda00;
  --border: #888;
  --clue-hover: #dce8f0;
  --clue-active: #a7d8ff;
  --error: #ff4444;
  --checked: #2a6dd4;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: #f5f5f5;
  color: #222;
  min-height: 100vh;
}

/* â”€â”€â”€ Calendar View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.calendar-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 16px;
  background: var(--white);
  border-bottom: 2px solid #ddd;
  flex-wrap: wrap;
}

.calendar-nav h1 {
  font-size: 1.3rem;
  font-weight: 700;
  margin-right: 12px;
}

.calendar-nav button, .calendar-nav select {
  padding: 6px 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.calendar-nav button:hover:not(:disabled) { background: #eee; }
.calendar-nav button:disabled { opacity: 0.4; cursor: default; }
.calendar-nav select { font-size: 0.85rem; }

.calendar-day-headers {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  max-width: 600px;
  margin: 12px auto 0;
  padding: 0 12px;
}
.calendar-day-headers span {
  text-align: center;
  font-size: 0.75rem;
  font-weight: 700;
  color: #888;
  text-transform: uppercase;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  max-width: 600px;
  margin: 6px auto 24px;
  padding: 0 12px;
}

.cal-day {
  aspect-ratio: 1;
  border-radius: 6px;
  border: 1.5px solid #ddd;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: transform 0.15s, box-shadow 0.15s;
  background: var(--white);
  display: flex;
  flex-direction: column;
  align-items: center;
}
.cal-day:hover:not(.empty) { transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.15); }
.cal-day.empty { background: transparent; border-color: transparent; cursor: default; }
.cal-day.no-puzzle { background: #fafafa; border-color: #eee; cursor: default; }
.cal-day.no-puzzle:hover { transform: none; box-shadow: none; }
.cal-day.today { border-color: #2a6dd4; border-width: 2.5px; }

.cal-day .day-number {
  font-size: 0.65rem;
  font-weight: 600;
  color: #555;
  margin-top: 2px;
  z-index: 1;
}
.cal-day.no-puzzle .day-number { color: #bbb; }

.cal-day canvas {
  image-rendering: pixelated;
  width: calc(100% - 6px);
  flex: 1;
  margin: 2px 3px 3px;
}

.star-overlay {
  display: none;
  position: absolute;
  inset: 0;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  pointer-events: none;
  text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.cal-day.complete .star-overlay { display: flex; }

.player-count-badge {
  position: absolute;
  top: 2px;
  right: 2px;
  background: #2a6dd4;
  color: #fff;
  font-size: 0.55rem;
  font-weight: 700;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  line-height: 1;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

/* â”€â”€â”€ Puzzle View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#puzzle-view { display: none; flex-direction: column; height: 100vh; overflow: hidden; }

.puzzle-header {
  text-align: center;
  padding: 16px;
  background: var(--white);
  border-bottom: 2px solid #ddd;
  flex-shrink: 0;
}
.puzzle-header .back-btn {
  position: absolute;
  left: 16px;
  top: 50%;
  transform: translateY(-50%);
  padding: 6px 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.puzzle-header .back-btn:hover { background: #eee; }
.puzzle-header { position: relative; }
.puzzle-header h1 { font-size: 1.3rem; font-weight: 700; }
.puzzle-header .meta { font-size: 0.85rem; color: #666; margin-top: 4px; }

.toolbar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  padding: 10px;
  background: var(--white);
  border-bottom: 1px solid #ddd;
  flex-wrap: wrap;
  flex-shrink: 0;
}
.toolbar button {
  padding: 6px 16px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: var(--white);
  cursor: pointer;
  font-size: 0.85rem;
  transition: background 0.15s;
}
.toolbar button:hover { background: #eee; }

.presence-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 6px 10px;
  background: #fafafa;
  border-bottom: 1px solid #eee;
  min-height: 28px;
  font-size: 0.78rem;
  flex-shrink: 0;
}
.presence-user {
  display: flex;
  align-items: center;
  gap: 4px;
}
.presence-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
}
.presence-filled {
  color: #888;
  font-size: 0.8em;
  font-variant-numeric: tabular-nums;
}
.presence-pts {
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}
.solve-timer {
  font-variant-numeric: tabular-nums;
  font-weight: 600;
  color: #555;
  margin-left: auto;
  font-size: 0.82rem;
}

.current-clue-bar {
  display: flex;
  align-items: center;
  padding: 8px 8px;
  background: var(--highlight-word);
  font-size: 0.95rem;
  font-weight: 500;
  min-height: 36px;
  flex-shrink: 0;
}
#clue-bar-text { flex: 1; text-align: center; }
.clue-nav-btn {
  background: none; border: none; font-size: 1.5rem; cursor: pointer;
  padding: 0 8px; color: #333; font-weight: 700;
}

.app {
  display: flex;
  justify-content: center;
  gap: 24px;
  padding: 16px 16px 24px;
  max-width: 1200px;
  margin: 0 auto;
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

/* Grid */
.grid-container { flex-shrink: 0; position: relative; align-self: flex-start; padding-top: 18px; padding-left: 64px; margin-bottom: 24px; }

.grid {
  display: grid;
  border: 2px solid var(--black);
  user-select: none;
  cursor: pointer;
  touch-action: manipulation;
}

.cell {
  position: relative;
  width: var(--cell-size);
  height: var(--cell-size);
  border: 0.5px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: calc(var(--cell-size) * 0.5);
  font-weight: 600;
  background: var(--white);
  transition: background 0.1s;
}

.cell.black {
  background: var(--black);
  border-color: var(--black);
}

.cell .number {
  position: absolute;
  top: 1px;
  left: 2px;
  font-size: calc(var(--cell-size) * 0.25);
  font-weight: 500;
  line-height: 1;
  color: #333;
}

.cell .letter {
  margin-top: 4px;
  text-transform: uppercase;
}

.cell.highlight-word { background: var(--highlight-word); }
.cell.highlight-cell { background: var(--highlight-cell); }
.cell.error .letter { color: var(--error); }
.cell.checked .letter { color: var(--checked); }

/* Rebus cells (multi-letter content) */
.cell .letter.rebus-text {
  font-size: calc(var(--cell-size) * 0.22);
  letter-spacing: -0.5px;
  margin-top: 5px;
  line-height: 1;
  overflow: hidden;
}
.cell.rebus-cell {
  border: 2px solid #333;
}
.cell.rebus-active {
  outline: 2.5px solid #2196F3;
  outline-offset: -2.5px;
  z-index: 2;
}
.rebus-indicator {
  font-size: 0.8rem;
  color: #555;
  margin-top: 4px;
  font-style: italic;
}
.toolbar button.active { background: #d0e0ff; }

/* Shaded cells */
.cell.shaded { background: var(--shade-color, #c0c0c0); }
.cell.shaded.highlight-word { background: color-mix(in srgb, var(--shade-color, #c0c0c0) 50%, var(--highlight-word)); }
.cell.shaded.highlight-cell { background: color-mix(in srgb, var(--shade-color, #c0c0c0) 40%, var(--highlight-cell)); }

/* Circled cells */
.cell.circled::after {
  content: '';
  position: absolute;
  inset: 1px;
  border: 1.5px solid #333;
  border-radius: 50%;
  pointer-events: none;
}

/* Clue Panel */
.clue-panel {
  display: flex;
  gap: 0;
  flex: 1;
  max-width: 700px;
  background: var(--white);
  border: 1px solid #ddd;
  border-radius: 6px;
  overflow: hidden;
  max-height: 100%;
}

.clue-section {
  flex: 1;
  overflow-y: auto;
  min-width: 0;
}
.clue-section + .clue-section {
  border-left: 1px solid #ddd;
}

.clue-section h2 {
  position: sticky;
  top: 0;
  background: #e8ecf0;
  padding: 8px 12px;
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border-bottom: 1px solid #ddd;
  z-index: 1;
}

.clue-item {
  padding: 6px 12px;
  font-size: 0.85rem;
  cursor: pointer;
  display: flex;
  gap: 8px;
  border-bottom: 1px solid #f0f0f0;
  transition: background 0.1s;
  scroll-margin-top: 36px;
}
.clue-item:hover { background: var(--clue-hover); }
.clue-item.active { background: var(--clue-active); }
.clue-item.solved { opacity: 0.45; text-decoration: line-through; }
.clue-item.solved.active { opacity: 0.6; }
.clue-item .clue-num { font-weight: 700; min-width: 24px; }
.clue-item .clue-text { flex: 1; }

/* Congratulations overlay */
.congrats-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.congrats-overlay.show { display: flex; }
.congrats-box {
  background: var(--white);
  padding: 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}
.congrats-box h2 { font-size: 1.8rem; margin-bottom: 8px; }
.congrats-box p { color: #666; margin-bottom: 20px; }
.congrats-box button {
  padding: 10px 28px;
  background: #2a6dd4;
  color: var(--white);
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
}

/* Word completion wave */
@keyframes cell-wave {
  0%   { transform: translateY(0); }
  40%  { transform: translateY(-4px); }
  70%  { transform: translateY(1px); }
  100% { transform: translateY(0); }
}
.cell.wave { animation: cell-wave 0.35s ease-in-out; }

/* Floating point indicators */
@keyframes float-up {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-28px); }
}
@keyframes float-up-slow {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  20% { opacity: 1; transform: translateY(-4px) scale(1.1); }
  100% { opacity: 0; transform: translateY(-34px) scale(1); }
}
.point-float {
  position: absolute;
  top: -2px;
  right: -2px;
  font-size: 22px;
  font-weight: 700;
  pointer-events: none;
  z-index: 10;
  animation: float-up 0.8s ease-out forwards;
  line-height: 1;
}
.point-float.plus { color: #2e7d32; }
.point-float.minus { color: #c62828; }
.point-float.word {
  font-size: 24px;
  color: #1565c0;
  left: 50%;
  right: auto;
  transform: translateX(-50%);
  white-space: nowrap;
  animation: float-up-slow 1.6s ease-out forwards;
}
.point-float.combo {
  font-size: 30px;
  font-weight: 900;
  color: #e65100;
  left: 50%;
  right: auto;
  transform: translateX(-50%);
  animation: float-up-slow 1.6s ease-out forwards;
  text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

/* Leaderboard in congrats */
.leaderboard { text-align: left; margin: 16px 0; }
.leaderboard-row {
  display: flex;
  align-items: center;
  padding: 6px 0;
  border-bottom: 1px solid #eee;
  font-size: 0.95rem;
}
.leaderboard-row:last-child { border-bottom: none; }
.leaderboard-rank { width: 24px; font-weight: 700; color: #888; }
.leaderboard-dot {
  width: 10px; height: 10px; border-radius: 50%;
  margin-right: 8px; flex-shrink: 0;
}
.leaderboard-name { flex: 1; font-weight: 600; }
.leaderboard-stats { text-align: right; color: #666; font-size: 0.85rem; }
.leaderboard-pts { font-weight: 700; margin-left: 8px; }

/* Hidden input for mobile keyboard */
.mobile-input {
  position: absolute;
  opacity: 0;
  width: 1px;
  height: 1px;
  top: -9999px;
  left: -9999px;
}

/* Mobile keyboard */
.mobile-keyboard {
  display: none;
  background: #2c2c2e;
  padding: 6px 4px;
  position: fixed;
  bottom: 0; left: 0; right: 0;
  z-index: 50;
}
.kb-row { display: flex; justify-content: center; gap: 4px; margin-bottom: 4px; }
.kb-key {
  background: #5a5a5c;
  color: #fff;
  border: none;
  border-radius: 5px;
  font-size: 1.1rem;
  font-weight: 600;
  min-width: 32px;
  height: 42px;
  cursor: pointer;
  flex: 1;
  max-width: 38px;
}
.kb-key:active { background: #7a7a7c; }
.kb-more, .kb-backspace { flex: 1.4; max-width: 54px; font-size: 0.8rem; }

/* User badge in calendar nav */
.user-badge {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 4px 12px;
  border-radius: 20px;
  background: #eef3f8;
  font-size: 0.82rem;
  font-weight: 600;
  color: #333;
  cursor: pointer;
  transition: background 0.15s;
  margin-right: 4px;
}
.user-badge:hover { background: #dce8f0; }
.user-badge:empty { display: none; }
.user-badge-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

/* Name prompt modal */
.name-modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
.name-modal-overlay.show { display: flex; }
.name-modal {
  background: var(--white);
  padding: 36px 40px;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  max-width: 340px;
  width: 90%;
}
.name-modal h2 { font-size: 1.4rem; margin-bottom: 6px; }
.name-modal p { color: #666; font-size: 0.9rem; margin-bottom: 18px; }
.name-modal input {
  width: 100%;
  padding: 10px 14px;
  border: 2px solid #ccc;
  border-radius: 6px;
  font-size: 1rem;
  margin-bottom: 14px;
  text-align: center;
  outline: none;
  transition: border-color 0.15s;
}
.name-modal input:focus { border-color: #2a6dd4; }
.name-modal button {
  padding: 10px 28px;
  background: #2a6dd4;
  color: var(--white);
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  width: 100%;
}
.name-modal button:disabled { opacity: 0.4; cursor: default; }
.color-picker {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}
.color-swatch {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: 3px solid transparent;
  cursor: pointer;
  transition: border-color 0.15s, transform 0.15s;
}
.color-swatch:hover { transform: scale(1.15); }
.color-swatch.selected { border-color: #222; transform: scale(1.15); }

/* Mobile */
body.mobile .calendar-nav { padding: 10px; gap: 6px; }
body.mobile .calendar-nav h1 { font-size: 1rem; margin-right: 6px; }
body.mobile .calendar-nav button, body.mobile .calendar-nav select { padding: 5px 8px; font-size: 0.78rem; }
body.mobile .user-badge { font-size: 0.72rem; padding: 3px 8px; }

body.mobile .calendar-day-headers, body.mobile .calendar-grid { max-width: 100%; padding: 0 6px; gap: 4px; }
body.mobile .cal-day .day-number { font-size: 0.55rem; }
body.mobile .star-overlay { font-size: 1.1rem; }

/* Puzzle view fills screen as flex column */
body.mobile #puzzle-view { position: fixed; inset: 0; overflow: hidden; }

body.mobile .puzzle-header { padding: 6px 10px; flex-shrink: 0; }
body.mobile .puzzle-header h1 { font-size: 0.95rem; }
body.mobile .puzzle-header .meta { display: none; }
body.mobile .puzzle-header .back-btn { left: 6px; padding: 5px 8px; font-size: 0.78rem; }

body.mobile .toolbar { gap: 6px; padding: 4px 8px; flex-shrink: 0; }
body.mobile .toolbar button { padding: 4px 10px; font-size: 0.78rem; }

body.mobile .presence-bar { flex-shrink: 0; }
body.mobile .fire-bar { flex-shrink: 0; }

body.mobile .current-clue-bar { font-size: 0.85rem; padding: 6px 10px; background: #2b2d5e; color: #fff; flex-shrink: 0; }
body.mobile .clue-nav-btn { color: #fff; }

/* Grid area fills remaining space */
body.mobile .app { flex: 1; min-height: 0; overflow: hidden; padding: 0; gap: 0; }
body.mobile .grid-container {
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  overflow: hidden;
  padding-left: 0;
}
body.mobile .grid { touch-action: none; }
body.mobile .hint-btn { left: auto; right: 4px; top: auto; bottom: 4px; transform: none; }
body.mobile .hint-btn:hover { transform: scale(1.1); }
body.mobile .clue-panel { display: none; }

/* Keyboard at bottom of flex column */
body.mobile .mobile-keyboard { display: block; position: static; flex-shrink: 0; padding-bottom: env(safe-area-inset-bottom, 0px); }

/* â”€â”€â”€ Fire streak effects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@keyframes fire-dance {
  0%, 100% {
    background-size: 30% 70%, 35% 100%, 28% 60%, 32% 80%, 26% 55%;
    background-position: 8% 100%, 28% 100%, 50% 100%, 72% 100%, 92% 100%;
    opacity: 0.8;
  }
  25% {
    background-size: 34% 90%, 30% 75%, 32% 85%, 28% 65%, 30% 80%;
    background-position: 10% 100%, 30% 100%, 48% 100%, 70% 100%, 90% 100%;
    opacity: 1;
  }
  50% {
    background-size: 28% 65%, 34% 95%, 26% 70%, 34% 90%, 28% 60%;
    background-position: 6% 100%, 26% 100%, 52% 100%, 74% 100%, 94% 100%;
    opacity: 0.85;
  }
  75% {
    background-size: 32% 80%, 28% 70%, 34% 95%, 26% 60%, 32% 75%;
    background-position: 12% 100%, 32% 100%, 50% 100%, 68% 100%, 88% 100%;
    opacity: 0.95;
  }
}
.cell.on-fire::before {
  content: '';
  position: absolute;
  top: -16px;
  left: -2px;
  right: -2px;
  height: 18px;
  background:
    radial-gradient(ellipse at 50% 100%, rgba(255,60,0,0.85) 0%, rgba(255,120,0,0.3) 50%, transparent 70%),
    radial-gradient(ellipse at 50% 100%, rgba(255,140,20,0.9) 0%, rgba(255,180,50,0.3) 45%, transparent 65%),
    radial-gradient(ellipse at 50% 100%, rgba(255,90,0,0.8) 0%, rgba(255,160,30,0.25) 50%, transparent 70%),
    radial-gradient(ellipse at 50% 100%, rgba(255,120,10,0.85) 0%, rgba(255,170,40,0.3) 45%, transparent 65%),
    radial-gradient(ellipse at 50% 100%, rgba(255,70,0,0.75) 0%, rgba(255,130,20,0.25) 50%, transparent 70%);
  background-repeat: no-repeat;
  background-size: 30% 70%, 35% 100%, 28% 60%, 32% 80%, 26% 55%;
  background-position: 8% 100%, 28% 100%, 50% 100%, 72% 100%, 92% 100%;
  filter: blur(1.5px);
  pointer-events: none;
  z-index: 5;
  animation: fire-dance 0.7s ease-in-out infinite;
}

/* Fire bar */
.fire-bar {
  display: none;
  position: relative;
  height: 22px;
  background: #1a1a2e;
  overflow: hidden;
  flex-shrink: 0;
}
.fire-bar.active { display: block; }
.fire-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6a00, #ffa500, #ffd700);
  transition: width 0.05s linear;
}
.fire-bar-label {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.72rem;
  font-weight: 700;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  pointer-events: none;
}

/* Combo broken overlay */
@keyframes combo-broken-anim {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
  30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
  70% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
}
.combo-broken {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.5);
  font-size: 1.8rem;
  font-weight: 900;
  color: #c62828;
  text-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
  z-index: 20;
  white-space: nowrap;
  animation: combo-broken-anim 1.5s ease-out forwards;
}

/* Fire-boosted point floats */
.point-float.fire-points {
  color: #ff6a00;
  text-shadow: 0 0 6px rgba(255,106,0,0.5);
}

/* Hint button */
@keyframes hint-glow {
  0%, 100% { box-shadow: 0 0 8px rgba(255,215,0,0.4); }
  50% { box-shadow: 0 0 18px rgba(255,215,0,0.8); }
}
.hint-btn {
  display: none;
  position: absolute;
  left: 2px;
  top: 50%;
  transform: translateY(-50%);
  width: 54px;
  padding: 8px 4px;
  border-radius: 12px;
  border: 2px solid #daa520;
  background: linear-gradient(135deg, #ffd700, #ffec80, #daa520);
  color: #5c3d00;
  font-size: 0.7rem;
  font-weight: 800;
  cursor: pointer;
  animation: hint-glow 2s ease-in-out infinite;
  z-index: 5;
  transition: transform 0.2s;
  text-align: center;
  line-height: 1.3;
  flex-direction: column;
}
.hint-btn:hover { transform: translateY(-50%) scale(1.1); }
.hint-btn.show { display: flex; align-items: center; justify-content: center; }
.hint-btn.voted { opacity: 0.7; border-style: dashed; }
.hint-btn .hint-icon { font-size: 1.2rem; }
.hint-btn .hint-votes { font-size: 0.6rem; margin-top: 2px; }

/* Flying hint letter */
.hint-flyer {
  position: fixed;
  z-index: 100;
  font-weight: 900;
  color: #b8860b;
  background: linear-gradient(135deg, #fff8dc, #ffd700);
  border: 2px solid #daa520;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  pointer-events: none;
  transition: all 0.6s cubic-bezier(0.2, 0, 0.2, 1);
  box-shadow: 0 0 12px rgba(255,215,0,0.6);
  opacity: 1;
}

/* Glitter particle */
@keyframes glitter-fade {
  0% { opacity: 1; transform: translate(0, 0) scale(1); }
  100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0); }
}
.hint-glitter {
  position: fixed;
  z-index: 99;
  pointer-events: none;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: radial-gradient(circle, #fff 0%, #ffd700 60%, transparent 100%);
  box-shadow: 0 0 4px #ffd700;
  animation: glitter-fade 0.5s ease-out forwards;
}

/* Hint (gold) cells â€” matches flyer look */
@keyframes hint-shimmer {
  0%, 100% { box-shadow: inset 0 0 6px rgba(255,215,0,0.3), 0 0 4px rgba(255,215,0,0.2); }
  50% { box-shadow: inset 0 0 10px rgba(255,215,0,0.6), 0 0 12px rgba(255,215,0,0.5); }
}
.cell.hint-cell {
  background: linear-gradient(135deg, #fff8dc, #ffd700) !important;
  border: 2px solid #daa520 !important;
  color: #b8860b !important;
  font-weight: 900;
  animation: hint-shimmer 2s ease-in-out infinite;
}

/* Completed word cells â€” gradient fill in player color */
.cell.word-complete {
  border-color: var(--wc-color, #4CAF50) !important;
}

/* â”€â”€â”€ Puzzle Entry Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.puzzle-entry-overlay {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 90;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
.puzzle-entry-overlay.show { display: flex; }

.puzzle-entry-card {
  background: var(--white);
  border-radius: 16px;
  padding: 36px 40px;
  text-align: center;
  box-shadow: 0 12px 48px rgba(0,0,0,0.4);
  max-width: 380px;
  width: 90%;
  animation: entry-slide-up 0.3s ease-out;
}
@keyframes entry-slide-up {
  from { opacity: 0; transform: translateY(24px); }
  to { opacity: 1; transform: translateY(0); }
}

.puzzle-entry-card .entry-date {
  font-size: 1.6rem;
  font-weight: 800;
  color: #222;
  margin-bottom: 4px;
}
.puzzle-entry-card .entry-weekday {
  font-size: 0.9rem;
  color: #888;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
}
.puzzle-entry-card .entry-meta {
  font-size: 0.82rem;
  color: #999;
  margin-bottom: 20px;
}
.puzzle-entry-card .entry-players-label {
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #aaa;
  margin-bottom: 8px;
}
.puzzle-entry-card .entry-players {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 20px;
  min-height: 24px;
}
.puzzle-entry-card .entry-player {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.82rem;
  font-weight: 600;
  color: #444;
}
.puzzle-entry-card .entry-player-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}
.puzzle-entry-card .entry-no-players {
  font-size: 0.82rem;
  color: #bbb;
  font-style: italic;
}

.puzzle-entry-card .entry-start-btn {
  width: 100%;
  padding: 14px;
  background: #2a6dd4;
  color: var(--white);
  border: none;
  border-radius: 8px;
  font-size: 1.05rem;
  font-weight: 700;
  cursor: pointer;
  transition: background 0.15s;
  margin-bottom: 10px;
}
.puzzle-entry-card .entry-start-btn:hover { background: #1d5cb8; }

.puzzle-entry-card .entry-change-name {
  background: none;
  border: none;
  color: #2a6dd4;
  font-size: 0.82rem;
  font-weight: 600;
  cursor: pointer;
  padding: 4px 8px;
}
.puzzle-entry-card .entry-change-name:hover { text-decoration: underline; }

.puzzle-entry-card .entry-user-preview {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 4px 12px;
  border-radius: 20px;
  background: #eef3f8;
  font-size: 0.82rem;
  font-weight: 600;
  color: #333;
  margin-bottom: 16px;
}
.puzzle-entry-card .entry-user-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}
</style>
</head>
<body>

<!-- â”€â”€â”€ Calendar View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="calendar-view">
  <div class="calendar-nav">
    <h1>NYT Crossword</h1>
    <a href="/jeopardy" style="padding:6px 14px; border-radius:4px; background:#060CE9; color:#D7A32A; text-decoration:none; font-weight:700; font-size:0.85rem; transition:opacity 0.15s;" onmouseover="this.style.opacity='0.85'" onmouseout="this.style.opacity='1'">Jeopardy!</a>
    <span class="user-badge" id="user-badge" title="Click to change name"></span>
    <button id="cal-prev">&lt;</button>
    <select id="cal-month"></select>
    <select id="cal-year"></select>
    <button id="cal-next">&gt;</button>
    <button id="cal-today">TODAY</button>
  </div>
  <div class="calendar-day-headers">
    <span>S</span><span>M</span><span>T</span><span>W</span><span>T</span><span>F</span><span>S</span>
  </div>
  <div class="calendar-grid" id="calendar-grid"></div>
</div>

<!-- â”€â”€â”€ Puzzle View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="puzzle-view">
  <div class="puzzle-header">
    <button class="back-btn" id="btn-back">&larr; Calendar</button>
    <h1 id="puzzle-title">The New York Times Crossword</h1>
    <div class="meta" id="puzzle-meta"></div>
    <div class="rebus-indicator" id="rebus-indicator" style="display:none">This puzzle contains rebus squares</div>
  </div>

  <div class="toolbar">
    <button id="btn-clear">Clear Puzzle</button>
    <button id="btn-reveal">Reveal Puzzle</button>
    <button id="btn-rebus" style="display:none">Rebus</button>
    <span class="solve-timer" id="solve-timer">0:00</span>
  </div>

  <div class="presence-bar" id="presence-bar"></div>

  <div class="fire-bar" id="fire-bar">
    <div class="fire-bar-fill" id="fire-bar-fill"></div>
    <div class="fire-bar-label" id="fire-bar-label">ON FIRE</div>
  </div>

  <div class="current-clue-bar" id="current-clue-bar">
    <button class="clue-nav-btn" id="clue-prev">&lsaquo;</button>
    <span id="clue-bar-text">&nbsp;</span>
    <button class="clue-nav-btn" id="clue-next">&rsaquo;</button>
  </div>

  <div class="app">
    <div class="grid-container">
      <div class="grid" id="grid" tabindex="0"></div>
      <button class="hint-btn" id="hint-btn" title="Vote for a hint"><span class="hint-icon">ðŸ’¡</span><span class="hint-votes" id="hint-votes"></span></button>
      <input type="text" id="mobile-input" class="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="characters" spellcheck="false">
    </div>
    <div class="clue-panel" id="clue-panel"></div>
  </div>

  <div class="mobile-keyboard" id="mobile-keyboard"></div>
</div>

<!-- â”€â”€â”€ Name Prompt Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div class="name-modal-overlay" id="name-modal">
  <div class="name-modal">
    <h2>Welcome!</h2>
    <p>Enter your name to start solving</p>
    <input type="text" id="name-input" placeholder="Your name" maxlength="20" autocomplete="off">
    <div class="color-picker" id="color-picker"></div>
    <button id="name-submit" disabled>Start</button>
  </div>
</div>

<div class="congrats-overlay" id="congrats">
  <div class="congrats-box">
    <h2 id="congrats-title">Congratulations!</h2>
    <p id="congrats-msg">You solved the crossword!</p>
    <div class="leaderboard" id="leaderboard"></div>
    <button onclick="document.getElementById('congrats').classList.remove('show')">Close</button>
  </div>
</div>

<!-- â”€â”€â”€ Puzzle Entry Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div class="puzzle-entry-overlay" id="puzzle-entry-overlay">
  <div class="puzzle-entry-card">
    <div class="entry-weekday" id="entry-weekday"></div>
    <div class="entry-date" id="entry-date"></div>
    <div class="entry-meta" id="entry-meta"></div>
    <div class="entry-user-preview" id="entry-user-preview"></div>
    <div class="entry-players-label">PLAYERS SOLVING</div>
    <div class="entry-players" id="entry-players"></div>
    <button class="entry-start-btn" id="entry-start-btn">Start Solving</button>
    <button class="entry-change-name" id="entry-change-name">Change Name / Color</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
// â”€â”€â”€ Sound Effects (Web Audio API) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new AudioCtx();
  return audioCtx;
}

// remote = true â†’ lower pitch (0.8x) and lower volume (0.4x)
const REMOTE_PITCH = 0.8;
const REMOTE_VOL = 0.4;

function sfxType(isCorrect, remote) {
  const p = remote ? REMOTE_PITCH : 1;
  const v = remote ? REMOTE_VOL : 1;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.value = (isCorrect ? 880 : 340) * p;
  gain.gain.setValueAtTime(0.08 * v, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 0.08);
}

function sfxWordComplete(remote) {
  const p = remote ? REMOTE_PITCH : 1;
  const v = remote ? REMOTE_VOL : 1;
  const ctx = getAudioCtx();
  const t = ctx.currentTime;
  [523, 659].forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = 'sine';
    osc.frequency.value = freq * p;
    const start = t + i * 0.09;
    gain.gain.setValueAtTime(0.1 * v, start);
    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.2);
    osc.start(start);
    osc.stop(start + 0.2);
  });
}

function sfxFireStart(remote) {
  const p = remote ? REMOTE_PITCH : 1;
  const v = remote ? REMOTE_VOL : 1;
  const ctx = getAudioCtx();
  const t = ctx.currentTime;
  [260, 330, 520, 780].forEach((freq) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(freq * 0.5 * p, t);
    osc.frequency.exponentialRampToValueAtTime(freq * 1.5 * p, t + 0.35);
    gain.gain.setValueAtTime(0.04 * v, t);
    gain.gain.linearRampToValueAtTime(0.07 * v, t + 0.15);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    osc.start(t);
    osc.stop(t + 0.4);
  });
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.value = 1047 * p;
  gain.gain.setValueAtTime(0, t + 0.15);
  gain.gain.linearRampToValueAtTime(0.12 * v, t + 0.2);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
  osc.start(t + 0.15);
  osc.stop(t + 0.6);
}

function sfxFireBreak(remote) {
  const p = remote ? REMOTE_PITCH : 1;
  const v = remote ? REMOTE_VOL : 1;
  const ctx = getAudioCtx();
  const t = ctx.currentTime;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(440 * p, t);
  osc.frequency.exponentialRampToValueAtTime(220 * p, t + 0.3);
  gain.gain.setValueAtTime(0.1 * v, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
  osc.start(t);
  osc.stop(t + 0.3);
}

function sfxVictory() {
  // Triumphant ascending arpeggio: C5 E5 G5 C6
  const ctx = getAudioCtx();
  const t = ctx.currentTime;
  [523, 659, 784, 1047].forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = 'sine';
    osc.frequency.value = freq;
    const start = t + i * 0.12;
    gain.gain.setValueAtTime(0.12, start);
    gain.gain.exponentialRampToValueAtTime(0.001, start + (i === 3 ? 0.6 : 0.25));
    osc.start(start);
    osc.stop(start + (i === 3 ? 0.6 : 0.25));
  });
}

// â”€â”€â”€ Device identity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getDeviceId() {
  let id = localStorage.getItem('crossword-device-id');
  if (!id) {
    id = crypto.randomUUID();
    localStorage.setItem('crossword-device-id', id);
  }
  return id;
}
const DEVICE_ID = getDeviceId();

let myName = '';
let myColor = '#90EE90';
let socket = null;

async function initIdentity() {
  try {
    const res = await fetch('/api/me', { headers: { 'X-Device-Id': DEVICE_ID } });
    const data = await res.json();
    if (data.name) {
      myName = data.name;
      myColor = data.color;
      connectSocket();
      return;
    }
  } catch (e) {
    // Fallback: show modal anyway
  }
  // No name yet â€” show prompt
  showNameModal();
}

const CLIENT_COLOR_POOL = ['#4CAF50','#2196F3','#FF9800','#E91E63','#9C27B0','#00BCD4'];

function showNameModal(isChange) {
  const modal = document.getElementById('name-modal');
  const input = document.getElementById('name-input');
  const btn = document.getElementById('name-submit');
  const picker = document.getElementById('color-picker');
  const heading = modal.querySelector('h2');
  const desc = modal.querySelector('p');

  let selectedColor = isChange ? myColor : null;

  // Populate color picker
  picker.innerHTML = '';
  for (const c of CLIENT_COLOR_POOL) {
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch' + (c === selectedColor ? ' selected' : '');
    swatch.style.background = c;
    swatch.addEventListener('click', () => {
      selectedColor = c;
      picker.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
      swatch.classList.add('selected');
    });
    picker.appendChild(swatch);
  }

  if (isChange) {
    heading.textContent = 'Change Name & Color';
    desc.textContent = 'Update your display name or outline color';
    btn.textContent = 'Save';
    input.value = myName;
    btn.disabled = false;
  } else {
    heading.textContent = 'Welcome!';
    desc.textContent = 'Enter your name to start solving';
    btn.textContent = 'Start';
    input.value = '';
    btn.disabled = true;
  }

  modal.classList.add('show');
  input.focus();
  input.select();

  // Clone and replace to remove old event listeners
  const newInput = input.cloneNode(true);
  input.parentNode.replaceChild(newInput, input);
  const newBtn = btn.cloneNode(true);
  btn.parentNode.replaceChild(newBtn, btn);

  newInput.addEventListener('input', () => {
    newBtn.disabled = !newInput.value.trim();
  });

  async function submit() {
    const name = newInput.value.trim();
    if (!name) return;
    newBtn.disabled = true;
    try {
      const body = { name };
      if (selectedColor) body.color = selectedColor;
      const res = await fetch('/api/me', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-Device-Id': DEVICE_ID },
        body: JSON.stringify(body),
      });
      const data = await res.json();
      myName = data.name;
      myColor = data.color;
      modal.classList.remove('show');
      updateUserBadge();
      if (!isChange) {
        connectSocket();
      } else {
        // Reconnect socket with new name/color
        if (socket) {
          socket.disconnect();
          socket = null;
        }
        connectSocket();
      }
    } catch (e) {
      newBtn.disabled = false;
      alert('Failed to save, please try again.');
    }
  }

  newBtn.addEventListener('click', submit);
  newInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submit();
  });
}

function updateUserBadge() {
  const badge = document.getElementById('user-badge');
  if (myName) {
    badge.innerHTML = `<span class="user-badge-dot" style="background:${myColor}"></span>${myName}`;
  } else {
    badge.innerHTML = '';
  }
}

// Click badge to change name
document.getElementById('user-badge').addEventListener('click', () => {
  showNameModal(true);
});

let appStarted = false;

function connectSocket() {
  socket = io({ query: { userId: myName, deviceId: DEVICE_ID } });

  socket.on('connect', () => {
    if (currentDate) socket.emit('join-puzzle', currentDate);
  });

  updateUserBadge();
  setupSocketHandlers();
  if (!appStarted) {
    appStarted = true;
    startApp();
  }
}

// â”€â”€â”€ Device detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const IS_MOBILE = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  || (navigator.maxTouchPoints > 1 && /Macintosh/.test(navigator.userAgent)); // iPad with desktop UA
if (IS_MOBILE) document.body.classList.add('mobile');

// â”€â”€â”€ Puzzle state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let PUZZLE = null;
let ROWS = 0, COLS = 0;
let userGrid = [];
let checkedCells = [];
let selectedRow = 0, selectedCol = 0;
let direction = 'across';
const autoCheck = true;
let solved = false;
let currentDate = null;
let rebusMode = false;
let rebusBuffer = '';

function getCorrectAnswer(r, c) {
  if (!PUZZLE) return '';
  const key = `${r},${c}`;
  return PUZZLE.rebus[key] || PUZZLE.grid[r]?.[c] || '';
}

function hasRebus() {
  return PUZZLE && Object.keys(PUZZLE.rebus).length > 0;
}

// Grid zoom state (mobile pinch-to-zoom)
let gridScale = 1, gridTx = 0, gridTy = 0;

// Solve timer state
let timerSeconds = 0;
let timerInterval = null;
const timerEl = document.getElementById('solve-timer');

function formatTimer(s) {
  const hrs = Math.floor(s / 3600);
  const mins = Math.floor((s % 3600) / 60);
  const secs = s % 60;
  if (hrs > 0) return `${hrs}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
  return `${mins}:${String(secs).padStart(2,'0')}`;
}

function updateTimerDisplay() {
  timerEl.textContent = formatTimer(timerSeconds);
}

function startTimerTick() {
  if (timerInterval) return;
  timerInterval = setInterval(() => {
    timerSeconds++;
    updateTimerDisplay();
  }, 1000);
}

function stopTimerTick() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

// â”€â”€â”€ Remote user presence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const remoteUsers = new Map(); // socketId â†’ {userId, userName, color, row, col, direction}
const cellColors = new Map();  // "r,c" â†’ color (who filled this cell)
const cellFillers = new Map(); // "r,c" â†’ {userName, color} (who filled this cell)
const guessStats = new Map(); // userName â†’ { total, incorrect }
const persistedPoints = new Map(); // userName â†’ number (base points from DB, excludes word bonuses)
const roomCounts = new Map();  // puzzleDate â†’ player count
let lastCursorKey = '';

// Fire streak state
let myFireActive = false;
let myFireExpiresAt = 0;
let myFireCells = new Set();    // "r,c" strings
let myFireBarInterval = null;
let myRecentWordCompletions = []; // [{timestamp,row,col},...] for tracking word completions toward fire
let myFireMultiplier = 1.5;
let myFireWordsCompleted = 0;
const remoteFireStates = new Map(); // socketId â†’ {userName, color, fireCells: Set, expiresAt}

// Completed word cells: "r,c" â†’ color of the player who completed the word
const completedWordCells = new Map();

// Hint system state
const hintCells = new Set(); // "r,c" strings â€” cells revealed by hints (cannot be deleted)
let lastWordCompletionTime = Date.now();
let hintCheckInterval = null;
let hintVoted = false; // whether this player has voted for current hint

// â”€â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const calendarView = document.getElementById('calendar-view');
const puzzleView = document.getElementById('puzzle-view');
const calendarGridEl = document.getElementById('calendar-grid');
const gridEl = document.getElementById('grid');
const cluePanelEl = document.getElementById('clue-panel');
const clueBarEl = document.getElementById('current-clue-bar');
const congratsEl = document.getElementById('congrats');
const titleEl = document.getElementById('puzzle-title');
const metaEl = document.getElementById('puzzle-meta');
const presenceBarEl = document.getElementById('presence-bar');
const btnClear = document.getElementById('btn-clear');
const btnReveal = document.getElementById('btn-reveal');
const btnRebus = document.getElementById('btn-rebus');
const btnBack = document.getElementById('btn-back');

// â”€â”€â”€ Calendar state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
const MONTH_NAMES = ['January','February','March','April','May','June','July','August','September','October','November','December'];

let calendarYear, calendarMonth; // calendarMonth is 0-indexed
const calendarData = new Map(); // date â†’ {date, rows, cols, cells, filledCount, totalWhite, isComplete}

function todayET() {
  return new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
}

function initCalendarNav() {
  const monthSel = document.getElementById('cal-month');
  const yearSel = document.getElementById('cal-year');

  for (let m = 0; m < 12; m++) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = MONTH_NAMES[m];
    monthSel.appendChild(opt);
  }

  const thisYear = new Date().getFullYear();
  for (let y = thisYear - 5; y <= thisYear + 1; y++) {
    const opt = document.createElement('option');
    opt.value = y;
    opt.textContent = y;
    yearSel.appendChild(opt);
  }

  // Restore saved month or default to current
  const savedYM = localStorage.getItem('crossword-calendar-month');
  const now = new Date();
  if (savedYM) {
    const [sy, sm] = savedYM.split('-').map(Number);
    calendarYear = sy;
    calendarMonth = sm;
  } else {
    calendarYear = now.getFullYear();
    calendarMonth = now.getMonth();
  }
  monthSel.value = calendarMonth;
  yearSel.value = calendarYear;

  monthSel.addEventListener('change', () => {
    calendarMonth = parseInt(monthSel.value);
    fetchAndRenderCalendar();
  });
  yearSel.addEventListener('change', () => {
    calendarYear = parseInt(yearSel.value);
    fetchAndRenderCalendar();
  });

  document.getElementById('cal-prev').addEventListener('click', () => {
    calendarMonth--;
    if (calendarMonth < 0) { calendarMonth = 11; calendarYear--; }
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
  document.getElementById('cal-next').addEventListener('click', () => {
    calendarMonth++;
    if (calendarMonth > 11) { calendarMonth = 0; calendarYear++; }
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
  document.getElementById('cal-today').addEventListener('click', () => {
    const now = new Date();
    calendarYear = now.getFullYear();
    calendarMonth = now.getMonth();
    syncCalendarSelects();
    fetchAndRenderCalendar();
  });
}

function syncCalendarSelects() {
  document.getElementById('cal-month').value = calendarMonth;
  document.getElementById('cal-year').value = calendarYear;
  // Enable/disable today button
  const now = new Date();
  const isCurrent = calendarYear === now.getFullYear() && calendarMonth === now.getMonth();
  document.getElementById('cal-today').disabled = isCurrent;
}

async function fetchAndRenderCalendar() {
  // Persist selected month
  localStorage.setItem('crossword-calendar-month', `${calendarYear}-${calendarMonth}`);
  const ym = `${calendarYear}-${String(calendarMonth + 1).padStart(2, '0')}`;
  try {
    const res = await fetch(`/api/calendar/${ym}`);
    const data = await res.json();
    // Clear old month data from map, add new
    for (const [key] of calendarData) {
      if (key.startsWith(ym)) calendarData.delete(key);
    }
    for (const item of data) {
      calendarData.set(item.date, item);
    }
  } catch (e) {
    // Silently ignore fetch errors
  }
  renderCalendar();
  syncCalendarSelects();
}

function renderCalendar() {
  calendarGridEl.innerHTML = '';

  const today = todayET();
  const firstDay = new Date(calendarYear, calendarMonth, 1).getDay();
  const daysInMonth = new Date(calendarYear, calendarMonth + 1, 0).getDate();

  // Empty cells before first day
  for (let i = 0; i < firstDay; i++) {
    const empty = document.createElement('div');
    empty.className = 'cal-day empty';
    calendarGridEl.appendChild(empty);
  }

  for (let day = 1; day <= daysInMonth; day++) {
    const dateStr = `${calendarYear}-${String(calendarMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const info = calendarData.get(dateStr);

    const dayEl = document.createElement('div');
    dayEl.className = 'cal-day';
    dayEl.dataset.date = dateStr;

    if (dateStr === today) dayEl.classList.add('today');

    const numEl = document.createElement('span');
    numEl.className = 'day-number';
    numEl.textContent = day;
    dayEl.appendChild(numEl);

    if (info) {
      if (info.isComplete) dayEl.classList.add('complete');

      const canvas = document.createElement('canvas');
      canvas.width = info.cols;
      canvas.height = info.rows;
      drawThumbnail(canvas, info);
      dayEl.appendChild(canvas);

      const star = document.createElement('div');
      star.className = 'star-overlay';
      star.textContent = '\u2B50';
      dayEl.appendChild(star);

      dayEl.addEventListener('click', () => showPuzzle(dateStr, true, true));
    } else {
      dayEl.classList.add('no-puzzle');
    }

    // Player count badge
    const playerCount = roomCounts.get(dateStr);
    if (playerCount > 0) {
      const badge = document.createElement('div');
      badge.className = 'player-count-badge';
      badge.textContent = playerCount;
      dayEl.appendChild(badge);
    }

    calendarGridEl.appendChild(dayEl);
  }
}

function drawThumbnail(canvas, info) {
  const ctx = canvas.getContext('2d');
  const { rows, cols, cells, filledCount, totalWhite, isComplete } = info;
  const hasProgress = filledCount > 0;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const val = cells[r * cols + c];
      if (val === 0) {
        // Black cell
        ctx.fillStyle = '#4a4a4a';
      } else if (isComplete) {
        // Complete puzzle
        ctx.fillStyle = val === 2 ? '#2a5599' : '#4a7abf';
      } else if (hasProgress) {
        // In progress
        ctx.fillStyle = val === 2 ? '#5b9bd5' : '#ffffff';
      } else {
        // No progress â€” gray palette
        ctx.fillStyle = val === 1 ? '#c8c8c8' : '#c8c8c8';
      }
      ctx.fillRect(c, r, 1, 1);
    }
  }
}

// â”€â”€â”€ View management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showCalendar(pushState = true) {
  puzzleView.style.display = 'none';
  calendarView.style.display = 'block';
  document.body.style.overflow = '';
  document.getElementById('puzzle-entry-overlay').classList.remove('show');
  document.title = 'NYT Crossword';

  if (currentDate) {
    if (socket) socket.emit('leave-puzzle');
    currentDate = null;
  }
  stopTimerTick();
  timerSeconds = 0;
  updateTimerDisplay();
  resetFireState();
  localStorage.removeItem('crossword-current-puzzle');
  PUZZLE = null;
  remoteUsers.clear();
  lastCursorKey = '';
  if (pushState) history.pushState({ view: 'calendar' }, '', '/');
  fetchAndRenderCalendar();
}

function showPuzzle(dateStr, pushState = true, showEntry = false) {
  calendarView.style.display = 'none';
  puzzleView.style.display = 'flex';
  document.body.style.overflow = 'hidden';
  if (pushState) history.pushState({ view: 'puzzle', date: dateStr }, '', `/${dateStr}`);

  // Always load the puzzle first so grid renders behind overlay
  loadPuzzle(dateStr);

  if (showEntry) {
    showPuzzleEntryOverlay(dateStr);
  }
}

// â”€â”€â”€ Puzzle Entry Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showPuzzleEntryOverlay(dateStr) {
  const overlay = document.getElementById('puzzle-entry-overlay');
  const dateEl = document.getElementById('entry-date');
  const weekdayEl = document.getElementById('entry-weekday');
  const metaEl2 = document.getElementById('entry-meta');
  const playersEl = document.getElementById('entry-players');
  const userPreviewEl = document.getElementById('entry-user-preview');
  const startBtn = document.getElementById('entry-start-btn');
  const changeNameBtn = document.getElementById('entry-change-name');

  // Parse date for display
  const [y, m, d] = dateStr.split('-').map(Number);
  const dateObj = new Date(y, m - 1, d);
  const weekday = DAYS[dateObj.getDay()];
  const monthName = MONTH_NAMES[m - 1];

  weekdayEl.textContent = weekday;
  dateEl.textContent = `${monthName} ${d}, ${y}`;
  metaEl2.textContent = '';

  // Show user preview
  if (myName) {
    userPreviewEl.innerHTML = `<span class="entry-user-dot" style="background:${myColor}"></span>Playing as ${myName}`;
    userPreviewEl.style.display = '';
  } else {
    userPreviewEl.style.display = 'none';
  }

  // Show current players
  playersEl.innerHTML = '';
  const count = roomCounts.get(dateStr) || 0;
  if (count > 0) {
    const el = document.createElement('div');
    el.className = 'entry-player';
    el.innerHTML = `<span class="entry-player-dot" style="background:#2a6dd4"></span>${count} player${count > 1 ? 's' : ''} solving`;
    playersEl.appendChild(el);
  } else {
    playersEl.innerHTML = '<div class="entry-no-players">No one here yet</div>';
  }

  // Show overlay immediately
  overlay.classList.add('show');

  // Fetch puzzle metadata in the background (non-blocking)
  fetch('/api/puzzles').then(r => r.json()).then(puzzles => {
    const puzzle = puzzles.find(p => p.date === dateStr);
    if (puzzle) {
      const parts = [];
      if (puzzle.author) parts.push(`By ${puzzle.author}`);
      if (puzzle.editor) parts.push(`Edited by ${puzzle.editor}`);
      metaEl2.textContent = parts.join(' \u00B7 ');
    }
  }).catch(() => {});

  // Start button â€” puzzle is already loaded behind the overlay
  const handleStart = () => {
    overlay.classList.remove('show');
    startBtn.removeEventListener('click', handleStart);
    changeNameBtn.removeEventListener('click', handleChangeName);
  };

  // Change name button
  const handleChangeName = () => {
    showNameModal(true);
    // After name changes, update the preview
    const observer = new MutationObserver(() => {
      if (!document.getElementById('name-modal').classList.contains('show')) {
        observer.disconnect();
        if (myName) {
          userPreviewEl.innerHTML = `<span class="entry-user-dot" style="background:${myColor}"></span>Playing as ${myName}`;
          userPreviewEl.style.display = '';
        }
      }
    });
    observer.observe(document.getElementById('name-modal'), { attributes: true, attributeFilter: ['class'] });
  };

  startBtn.addEventListener('click', handleStart);
  changeNameBtn.addEventListener('click', handleChangeName);
}

// â”€â”€â”€ Compute cell size to fit viewport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function computeAndApplyCellSize() {
  if (!PUZZLE) return;
  let cellSize;
  if (IS_MOBILE) {
    const availW = window.innerWidth - 8;
    const availH = window.innerHeight - 260;
    cellSize = Math.max(16, Math.min(40, Math.floor(Math.min(availW / COLS, availH / ROWS))));
  } else {
    const maxGridW = Math.min(window.innerWidth - 420, 650);
    // Dynamically measure height of fixed elements above .app
    const appEl = document.querySelector('.app');
    const appTop = appEl ? appEl.getBoundingClientRect().top : 200;
    // Reserve space for fire bar (22px) even when hidden
    const fireBar = document.getElementById('fire-bar');
    const fireBarReserve = (fireBar && fireBar.classList.contains('active')) ? 0 : 22;
    // Internal overhead: app padding (16+24) + grid-container padding-top (18) + margin-bottom (24) + grid border (4)
    const internal = 86;
    const maxGridH = window.innerHeight - appTop - fireBarReserve - internal;
    cellSize = Math.max(16, Math.min(40, Math.floor(Math.min(maxGridW / COLS, maxGridH / ROWS))));
  }
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
}

// â”€â”€â”€ Load a puzzle (async) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadPuzzle(dateStr) {
  currentDate = dateStr;
  localStorage.setItem('crossword-current-puzzle', dateStr);
  remoteUsers.clear();
  cellColors.clear();
  cellFillers.clear();
  persistedPoints.clear();
  guessStats.clear();
  completedWordCells.clear();
  lastCursorKey = '';
  resetFireState();
  hintCells.clear();
  hideHintBtn();
  if (hintCheckInterval) clearInterval(hintCheckInterval);

  // Fetch puzzle data and shared state in parallel
  let data, stateData;
  try {
    const [puzzleRes, stateRes] = await Promise.all([
      fetch(`/api/puzzles/${dateStr}`),
      fetch(`/api/state/${dateStr}`),
    ]);
    if (!puzzleRes.ok) { alert('Puzzle not found'); showCalendar(); return; }
    data = await puzzleRes.json();
    stateData = await stateRes.json();
  } catch (e) {
    alert('Failed to load puzzle');
    showCalendar();
    return;
  }

  ROWS = data.dimensions.rows;
  COLS = data.dimensions.cols;

  const mapClues = (arr) => arr.map(c => ({
    n: c.number, clue: c.clue, answer: c.answer, row: c.row, col: c.col
  }));

  // Build circle and shade lookup sets
  const circleSet = new Set();
  if (data.circles) {
    for (const [r, c] of data.circles) circleSet.add(`${r},${c}`);
  }
  const shadeMap = new Map();
  if (data.shades) {
    for (const [r, c, color] of data.shades) shadeMap.set(`${r},${c}`, color);
  }

  PUZZLE = {
    rows: ROWS,
    cols: COLS,
    grid: data.grid,
    cellNumbers: data.cellNumbers,
    circles: circleSet,
    shades: shadeMap,
    rebus: data.rebus || {},
    clues: {
      across: mapClues(data.clues.across),
      down: mapClues(data.clues.down),
    },
  };

  // Reset state
  userGrid = Array.from({length: ROWS}, () => Array(COLS).fill(''));
  checkedCells = Array.from({length: ROWS}, () => Array(COLS).fill(false));
  solved = false;
  direction = 'across';
  rebusMode = false;
  rebusBuffer = '';
  congratsEl.classList.remove('show');

  // Show rebus button only for puzzles that have rebus cells
  btnRebus.style.display = hasRebus() ? '' : 'none';
  btnRebus.classList.remove('active');

  // Apply shared state
  applySharedState(stateData.userGrid || {}, stateData.cellFillers || {}, stateData.points || {}, stateData.userColors || {}, stateData.guesses || {});

  // Mark all correct letters as checked (auto-check is always on)
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (userGrid[r][c] && userGrid[r][c] === getCorrectAnswer(r, c))
        checkedCells[r][c] = true;

  // Scan for already-completed words and assign filler colors
  completedWordCells.clear();
  for (const dir of ['across', 'down']) {
    if (!PUZZLE.clues[dir]) continue;
    for (const clue of PUZZLE.clues[dir]) {
      const cells = getWordCells(clue, dir);
      if (cells.every(([r, c]) => userGrid[r][c] && userGrid[r][c] === getCorrectAnswer(r, c))) {
        // Find majority filler color for this word
        const colorCounts = {};
        for (const [r, c] of cells) {
          const filler = cellFillers.get(`${r},${c}`);
          if (filler && filler.color) {
            colorCounts[filler.color] = (colorCounts[filler.color] || 0) + 1;
          }
        }
        let bestColor = myColor;
        let bestCount = 0;
        for (const [col, cnt] of Object.entries(colorCounts)) {
          if (cnt > bestCount) { bestCount = cnt; bestColor = col; }
        }
        for (const [r, c] of cells) {
          completedWordCells.set(`${r},${c}`, bestColor);
        }
      }
    }
  }

  // Update header
  const d = new Date(dateStr + 'T12:00:00');
  const dayName = DAYS[d.getDay()];
  const prettyDate = `${dayName}, ${MONTH_NAMES[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
  titleEl.textContent = data.title || 'The New York Times Crossword';
  metaEl.textContent = `${prettyDate} \u00B7 By ${data.author} \u00B7 Edited by ${data.editor}`;
  document.getElementById('rebus-indicator').style.display = hasRebus() ? '' : 'none';
  document.title = `Crossword \u2014 ${prettyDate}`;

  computeAndApplyCellSize();
  window.removeEventListener('resize', computeAndApplyCellSize);
  window.addEventListener('resize', computeAndApplyCellSize);

  buildGrid();
  buildCluePanel();

  // Select first white cell
  selectedRow = 0; selectedCol = 0;
  for (let r = 0; r < ROWS; r++) {
    let found = false;
    for (let c = 0; c < COLS; c++) {
      if (!isBlack(r, c)) { selectedRow = r; selectedCol = c; found = true; break; }
    }
    if (found) break;
  }

  render();
  focusGrid();

  // Join puzzle room via Socket.IO
  if (socket) socket.emit('join-puzzle', dateStr);

  // Start hint timer
  startHintTimer();
}

// â”€â”€â”€ Collaboration helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applySharedState(gridMap, fillersMap, pointsMap, userColorsMap, guessesMap) {
  for (const [key, letter] of Object.entries(gridMap)) {
    const [r, c] = key.split(',').map(Number);
    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
      userGrid[r][c] = letter;
    }
  }
  // Apply persisted cell fillers with real colors
  if (fillersMap) {
    for (const [key, name] of Object.entries(fillersMap)) {
      if (name) {
        if (name === '(hint)') {
          hintCells.add(key);
        } else {
          const color = (userColorsMap && userColorsMap[name]) || (name === myName ? myColor : '#ccc');
          cellFillers.set(key, { userName: name, color });
          cellColors.set(key, color);
        }
      }
    }
  }
  // Apply persisted base points
  if (pointsMap) {
    for (const [name, pts] of Object.entries(pointsMap)) {
      persistedPoints.set(name, pts);
    }
  }
  // Apply persisted guess stats
  if (guessesMap) {
    for (const [name, stats] of Object.entries(guessesMap)) {
      guessStats.set(name, { total: stats.total || 0, incorrect: stats.incorrect || 0 });
    }
  }
}

function showPointFloat(row, col, delta, type, isFireBoosted) {
  if (!delta || !cellEls[row]?.[col]) return;
  const el = cellEls[row][col];
  const float = document.createElement('span');
  if (type === 'combo') {
    float.className = 'point-float combo';
    float.textContent = `+${delta} COMBO`;
  } else if (type === 'word') {
    float.className = 'point-float word';
    float.textContent = `word complete +${delta}`;
  } else {
    float.className = `point-float ${delta > 0 ? 'plus' : 'minus'}`;
    float.textContent = delta > 0 ? `+${delta}` : `${delta}`;
  }
  if (isFireBoosted && delta > 0) float.classList.add('fire-points');
  el.appendChild(float);
  float.addEventListener('animationend', () => float.remove());
}

function checkLocalWordBonus(row, col) {
  if (!PUZZLE) return { bonus: 0, completed: 0, wordCellKeys: [] };
  let completed = 0;
  const wordCellKeys = [];
  for (const dir of ['across', 'down']) {
    const clue = getClueForCell(row, col, dir);
    if (!clue) continue;
    const cells = getWordCells(clue, dir);
    if (cells.every(([r, c]) => userGrid[r][c] && userGrid[r][c] === getCorrectAnswer(r, c))) {
      completed++;
      for (const [r, c] of cells) wordCellKeys.push(`${r},${c}`);
    }
  }
  let bonus = 0;
  if (completed >= 2) bonus = 150;
  else if (completed === 1) bonus = 50;
  return { bonus, completed, wordCellKeys };
}

function triggerWordWave(row, col, completerColor) {
  if (!PUZZLE) return;
  const color = completerColor || myColor;
  for (const dir of ['across', 'down']) {
    const clue = getClueForCell(row, col, dir);
    if (!clue) continue;
    const cells = getWordCells(clue, dir);
    if (!cells.every(([r, c]) => userGrid[r][c] && userGrid[r][c] === getCorrectAnswer(r, c))) continue;
    cells.forEach(([r, c], i) => {
      const key = `${r},${c}`;
      completedWordCells.set(key, color);
      const el = cellEls[r]?.[c];
      if (!el) return;
      setTimeout(() => {
        el.classList.remove('wave');
        void el.offsetWidth;
        el.classList.add('wave');
        el.addEventListener('animationend', () => el.classList.remove('wave'), { once: true });
      }, i * 50);
    });
  }
  render();
}

function sendCellUpdate(row, col, letter) {
  if (!currentDate || !socket) return;
  const key = `${row},${col}`;
  // Prevent modifying hint cells (cannot delete or overwrite)
  if (hintCells.has(key)) return;
  if (letter) {
    cellColors.set(key, myColor);
    cellFillers.set(key, { userName: myName, color: myColor });
    // Immediate local point scoring with fire mechanic
    if (PUZZLE) {
      const correct = getCorrectAnswer(row, col);
      const isCorrect = (letter === correct);
      const now = Date.now();
      const wasOnFire = myFireActive;

      // Track guess stats
      const gs = guessStats.get(myName) || { total: 0, incorrect: 0 };
      gs.total++;
      if (!isCorrect) gs.incorrect++;
      guessStats.set(myName, gs);

      sfxType(isCorrect);

      if (isCorrect && myFireActive) {
        // Correct + on fire: multiplied points
        const firePts = Math.round(10 * myFireMultiplier);
        persistedPoints.set(myName, (persistedPoints.get(myName) || 0) + firePts);
        showPointFloat(row, col, firePts, null, true);
      } else if (isCorrect && !myFireActive) {
        // Correct + not on fire: normal point
        persistedPoints.set(myName, (persistedPoints.get(myName) || 0) + 10);
        showPointFloat(row, col, 10);
      } else if (!isCorrect && myFireActive) {
        // Incorrect + on fire: break fire
        persistedPoints.set(myName, (persistedPoints.get(myName) || 0) - 30);
        showPointFloat(row, col, -30);
        breakMyFire();
      } else {
        // Incorrect + not on fire: reset word completion streak
        myRecentWordCompletions = [];
        persistedPoints.set(myName, (persistedPoints.get(myName) || 0) - 30);
        showPointFloat(row, col, -30);
      }

      // Word completion bonus (check after grid is updated)
      if (isCorrect) {
        const { bonus: rawWb, completed: wordsCompleted, wordCellKeys } = checkLocalWordBonus(row, col);
        if (rawWb > 0) {
          resetHintTimer();
          // Apply fire multiplier to word bonus if was already on fire (not if fire starts this turn)
          let wb = rawWb;
          if (wasOnFire) wb = Math.round(wb * myFireMultiplier);
          persistedPoints.set(myName, (persistedPoints.get(myName) || 0) + wb);
          setTimeout(() => showPointFloat(row, col, wb, wb >= (wasOnFire ? 75 : 150) ? 'combo' : 'word', wasOnFire), 200);
          sfxWordComplete();
          triggerWordWave(row, col);

          // Get all cells this user has filled for fire display
          const allUserCells = [];
          for (const [key, filler] of cellFillers) {
            if (filler.userName === myName) allUserCells.push(key);
          }

          // Extend fire on word completion while on fire
          if (myFireActive && wasOnFire) {
            myFireWordsCompleted += wordsCompleted;
            myFireMultiplier = 1.5 + Math.floor(myFireWordsCompleted / 3) * 0.5;
            extendMyFire(allUserCells, myFireExpiresAt + 5000);
          }

          // Track word completions toward fire trigger (only when not on fire)
          if (!myFireActive) {
            myRecentWordCompletions.push({ timestamp: now, count: wordsCompleted, wordCells: wordCellKeys });
            myRecentWordCompletions = myRecentWordCompletions.filter(e => now - e.timestamp < 30000);
            const totalCompletions = myRecentWordCompletions.reduce((sum, e) => sum + e.count, 0);
            if (totalCompletions >= 3) {
              myFireMultiplier = 1.5;
              myFireWordsCompleted = 0;
              startMyFire(allUserCells, now + 30000);
              myRecentWordCompletions = [];
            }
          }
        }
      }
    }
  } else {
    cellColors.delete(key);
    cellFillers.delete(key);
    // Deleting a letter does NOT break fire or count toward streak
  }
  socket.emit('cell-update', { puzzleDate: currentDate, row, col, letter });
}

// â”€â”€â”€ Hint system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startHintTimer() {
  lastWordCompletionTime = Date.now();
  hintVoted = false;
  if (hintCheckInterval) clearInterval(hintCheckInterval);
  hintCheckInterval = setInterval(() => {
    if (solved) { hideHintBtn(); return; }
    const elapsed = Date.now() - lastWordCompletionTime;
    if (elapsed >= 60000) {
      showHintBtn();
      // Notify server that hint is available (so all clients can see it)
      if (socket && currentDate) socket.emit('hint-available', { puzzleDate: currentDate });
    }
  }, 5000);
}

function resetHintTimer() {
  lastWordCompletionTime = Date.now();
  hintVoted = false;
  hideHintBtn();
}

function showHintBtn() {
  const btn = document.getElementById('hint-btn');
  if (btn) {
    btn.classList.add('show');
    btn.classList.toggle('voted', hintVoted);
    updateHintVoteText(0, 0);
  }
}

function hideHintBtn() {
  const btn = document.getElementById('hint-btn');
  if (btn) {
    btn.classList.remove('show');
    btn.classList.remove('voted');
  }
  hintVoted = false;
}

function updateHintVoteText(votes, total) {
  const el = document.getElementById('hint-votes');
  if (!el) return;
  if (votes > 0 || total > 0) {
    el.textContent = `${votes}/${total}`;
  } else {
    el.textContent = 'Hint';
  }
}

function voteForHint() {
  if (!PUZZLE || !socket || !currentDate || hintVoted) return;
  hintVoted = true;
  const btn = document.getElementById('hint-btn');
  if (btn) btn.classList.add('voted');
  socket.emit('hint-vote', { puzzleDate: currentDate });
}

function applyHintReveal(cells) {
  lastWordCompletionTime = Date.now();
  hintVoted = false;

  // Get hint button position for fly-from origin
  const btn = document.getElementById('hint-btn');
  const btnRect = btn ? btn.getBoundingClientRect() : null;
  const btnX = btnRect ? btnRect.left + btnRect.width / 2 : 0;
  const btnY = btnRect ? btnRect.top + btnRect.height / 2 : 0;

  hideHintBtn();

  // Get cell size for flyer dimensions
  const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 32;

  cells.forEach(({ row: r, col: c, letter }, i) => {
    const key = `${r},${c}`;
    hintCells.add(key);
    userGrid[r][c] = letter;

    // Create flying letter element
    const cellEl = cellEls[r]?.[c];
    if (!cellEl || !btnRect) return;

    const targetRect = cellEl.getBoundingClientRect();
    const flyer = document.createElement('div');
    flyer.className = 'hint-flyer';
    flyer.textContent = letter;
    flyer.style.width = cellSize + 'px';
    flyer.style.height = cellSize + 'px';
    flyer.style.fontSize = (cellSize * 0.5) + 'px';
    // Start at button center
    flyer.style.left = (btnX - cellSize / 2) + 'px';
    flyer.style.top = (btnY - cellSize / 2) + 'px';
    flyer.style.transform = 'scale(0.3)';
    flyer.style.opacity = '0.6';
    document.body.appendChild(flyer);

    // Stagger each letter slightly
    let glitterInterval;
    setTimeout(() => {
      flyer.style.left = targetRect.left + 'px';
      flyer.style.top = targetRect.top + 'px';
      flyer.style.transform = 'scale(1)';
      flyer.style.opacity = '1';
      // Spawn glitter particles along the path
      glitterInterval = setInterval(() => {
        const rect = flyer.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        for (let p = 0; p < 2; p++) {
          const spark = document.createElement('div');
          spark.className = 'hint-glitter';
          const ox = (Math.random() - 0.5) * cellSize;
          const oy = (Math.random() - 0.5) * cellSize;
          spark.style.left = (cx + ox) + 'px';
          spark.style.top = (cy + oy) + 'px';
          spark.style.setProperty('--dx', (Math.random() - 0.5) * 20 + 'px');
          spark.style.setProperty('--dy', (Math.random() - 0.5) * 20 + 'px');
          spark.style.width = (3 + Math.random() * 5) + 'px';
          spark.style.height = spark.style.width;
          document.body.appendChild(spark);
          spark.addEventListener('animationend', () => spark.remove());
        }
      }, 40);
    }, i * 100);

    // After animation, remove flyer and glitter, show real cell
    setTimeout(() => {
      if (glitterInterval) clearInterval(glitterInterval);
      flyer.remove();
      render();
    }, i * 100 + 650);
  });

  // Final render + completion check after all animations
  setTimeout(() => {
    render();
    checkCompletion();
  }, cells.length * 100 + 700);
}

// â”€â”€â”€ Fire streak helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetFireState() {
  myFireActive = false;
  myFireExpiresAt = 0;
  myFireCells.clear();
  myRecentWordCompletions = [];
  myFireMultiplier = 1.5;
  myFireWordsCompleted = 0;
  remoteFireStates.clear();
  hideFireBar();
}

function startMyFire(fireCellKeys, expiresAt) {
  myFireActive = true;
  myFireExpiresAt = expiresAt;
  myFireCells = new Set(fireCellKeys);
  sfxFireStart();
  showFireBar();
  applyFireCellEffects();
}

function extendMyFire(cellKeys, newExpiresAt) {
  myFireExpiresAt = newExpiresAt;
  removeFireCellEffects();
  myFireCells = new Set(cellKeys);
  applyFireCellEffects();
  // Fire bar is already running, it'll pick up the new expiry
}

function breakMyFire() {
  sfxFireBreak();
  showComboBroken();
  hideFireBar();
  removeFireCellEffects();
  myFireActive = false;
  myFireExpiresAt = 0;
  myFireCells.clear();
  myRecentWordCompletions = [];
  myFireMultiplier = 1.5;
  myFireWordsCompleted = 0;
}

function expireMyFire() {
  hideFireBar();
  removeFireCellEffects();
  myFireActive = false;
  myFireExpiresAt = 0;
  myFireCells.clear();
  myRecentWordCompletions = [];
  myFireMultiplier = 1.5;
  myFireWordsCompleted = 0;
}

function applyFireCellEffects() {
  for (const key of myFireCells) {
    const [r, c] = key.split(',').map(Number);
    if (cellEls[r]?.[c]) cellEls[r][c].classList.add('on-fire');
  }
}

function removeFireCellEffects() {
  for (const key of myFireCells) {
    const [r, c] = key.split(',').map(Number);
    if (cellEls[r]?.[c]) cellEls[r][c].classList.remove('on-fire');
  }
}

function showFireBar() {
  const bar = document.getElementById('fire-bar');
  bar.classList.add('active');
  if (myFireBarInterval) clearInterval(myFireBarInterval);
  myFireBarInterval = setInterval(() => {
    const now = Date.now();
    const remaining = myFireExpiresAt - now;
    if (remaining <= 0) {
      expireMyFire();
      return;
    }
    const totalDuration = 30000; // base duration for percentage
    const pct = Math.min(100, (remaining / totalDuration) * 100);
    document.getElementById('fire-bar-fill').style.width = pct + '%';
    const multStr = myFireMultiplier % 1 === 0 ? myFireMultiplier.toFixed(0) : myFireMultiplier.toFixed(1);
    document.getElementById('fire-bar-label').textContent = `ON FIRE ${multStr}x \u00B7 ${(remaining / 1000).toFixed(1)}s`;
  }, 50);
}

function hideFireBar() {
  const bar = document.getElementById('fire-bar');
  bar.classList.remove('active');
  if (myFireBarInterval) {
    clearInterval(myFireBarInterval);
    myFireBarInterval = null;
  }
}

function showComboBroken() {
  const container = document.querySelector('.grid-container');
  if (!container) return;
  const el = document.createElement('div');
  el.className = 'combo-broken';
  el.textContent = 'COMBO BROKEN';
  container.appendChild(el);
  el.addEventListener('animationend', () => el.remove());
}

function handleRemoteFireEvent(fireEvent, remoteUserId) {
  // Find socketId for this remote user
  let remoteSocketId = null;
  for (const [sid, u] of remoteUsers) {
    if (u.userName === fireEvent.userName) { remoteSocketId = sid; break; }
  }
  if (!remoteSocketId) return;

  if (fireEvent.type === 'started') {
    const fireCellSet = new Set(fireEvent.fireCells.map(c => `${c.row},${c.col}`));
    remoteFireStates.set(remoteSocketId, {
      userName: fireEvent.userName, color: fireEvent.color,
      fireCells: fireCellSet, expiresAt: Date.now() + fireEvent.remainingMs,
    });
    for (const key of fireCellSet) {
      const [r, c] = key.split(',').map(Number);
      if (cellEls[r]?.[c]) cellEls[r][c].classList.add('on-fire');
    }
  } else if (fireEvent.type === 'extended') {
    const rs = remoteFireStates.get(remoteSocketId);
    if (rs) {
      for (const c of fireEvent.fireCells) {
        rs.fireCells.add(`${c.row},${c.col}`);
      }
      rs.expiresAt = Date.now() + fireEvent.remainingMs;
      for (const key of rs.fireCells) {
        const [r2, c2] = key.split(',').map(Number);
        if (cellEls[r2]?.[c2]) cellEls[r2][c2].classList.add('on-fire');
      }
    }
  } else if (fireEvent.type === 'broken') {
    const rs = remoteFireStates.get(remoteSocketId);
    if (rs) {
      for (const key of rs.fireCells) {
        const [r, c] = key.split(',').map(Number);
        if (cellEls[r]?.[c]) cellEls[r][c].classList.remove('on-fire');
      }
      remoteFireStates.delete(remoteSocketId);
    }
    showComboBroken();
  }
}

function broadcastCursor() {
  if (!currentDate || !socket) return;
  const key = `${selectedRow},${selectedCol},${direction}`;
  if (key === lastCursorKey) return;
  lastCursorKey = key;
  socket.emit('cursor-move', { puzzleDate: currentDate, row: selectedRow, col: selectedCol, direction });
}

// â”€â”€â”€ Socket.IO event handlers for puzzle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupSocketHandlers() {
  socket.on('room-state', ({ users, yourColor, yourName }) => {
    myColor = yourColor;
    if (yourName) myName = yourName;
    remoteUsers.clear();
    for (const u of users) {
      remoteUsers.set(u.socketId, { userId: u.userId, userName: u.userName || 'User', color: u.color, row: u.row, col: u.col, direction: u.direction });
    }
    // Update filler colors from room users
    updateFillerColorsFromRoom();
    renderPresenceBar();
    if (PUZZLE) render();
  });

  socket.on('user-joined', ({ socketId, userId, userName: uName, color, row, col, direction: dir }) => {
    remoteUsers.set(socketId, { userId, userName: uName || 'User', color, row, col, direction: dir });
    renderPresenceBar();
    if (PUZZLE) render();
  });

  socket.on('user-left', ({ socketId }) => {
    remoteUsers.delete(socketId);
    renderPresenceBar();
    if (PUZZLE) render();
  });

  socket.on('cursor-moved', ({ socketId, userId, userName: uName, row, col, direction: dir }) => {
    const user = remoteUsers.get(socketId);
    if (user) {
      user.row = row;
      user.col = col;
      user.direction = dir;
    } else {
      remoteUsers.set(socketId, { userId, userName: uName || 'User', color: '#ccc', row, col, direction: dir });
    }
    if (PUZZLE) render();
  });

  socket.on('cell-updated', ({ row, col, letter, userId: remoteUserId, userName: remoteName, color: remoteColor, pointDelta, wordBonus, fireEvent, guessCorrect, lastSquareBonus }) => {
    if (!PUZZLE) return;
    if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
      userGrid[row][col] = letter;
      const key = `${row},${col}`;
      if (letter) {
        const color = remoteColor || findColorForUser(remoteUserId);
        cellColors.set(key, color);
        cellFillers.set(key, { userName: remoteName || 'User', color });
        if (autoCheck && letter === getCorrectAnswer(row, col)) {
          checkedCells[row][col] = true;
        }
        // Track remote guess stats
        if (guessCorrect !== null && guessCorrect !== undefined && remoteName) {
          const gs = guessStats.get(remoteName) || { total: 0, incorrect: 0 };
          gs.total++;
          if (!guessCorrect) gs.incorrect++;
          guessStats.set(remoteName, gs);
        }
      } else {
        cellColors.delete(key);
        cellFillers.delete(key);
      }
      // Apply remote point delta
      const isFireBoosted = fireEvent && (fireEvent.type === 'started' || fireEvent.type === 'extended');
      if (pointDelta && remoteName) {
        persistedPoints.set(remoteName, (persistedPoints.get(remoteName) || 0) + pointDelta);
        showPointFloat(row, col, pointDelta, null, isFireBoosted);
      }
      // Apply remote word bonus
      if (wordBonus && remoteName) {
        resetHintTimer();
        persistedPoints.set(remoteName, (persistedPoints.get(remoteName) || 0) + wordBonus);
        const isCombo = wordBonus >= 150;
        setTimeout(() => showPointFloat(row, col, wordBonus, isCombo ? 'combo' : 'word', isFireBoosted), 200);
        triggerWordWave(row, col, remoteColor);
      }
      // Apply remote last-square bonus
      if (lastSquareBonus && remoteName) {
        persistedPoints.set(remoteName, (persistedPoints.get(remoteName) || 0) + lastSquareBonus);
        setTimeout(() => showPointFloat(row, col, lastSquareBonus, 'combo', false), 400);
      }
      // Handle remote fire events
      if (fireEvent) {
        handleRemoteFireEvent(fireEvent, remoteUserId);
      }
      render();
      checkCompletion();
    }
  });

  socket.on('timer-sync', ({ seconds }) => {
    timerSeconds = seconds;
    updateTimerDisplay();
    startTimerTick();
  });

  socket.on('puzzle-cleared', () => {
    if (!PUZZLE) return;
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS; c++) {
        userGrid[r][c] = '';
        checkedCells[r][c] = false;
      }
    cellColors.clear();
    cellFillers.clear();
    persistedPoints.clear();
    guessStats.clear();
    completedWordCells.clear();
    resetFireState();
    hintCells.clear();
    hideHintBtn();
    solved = false;
    congratsEl.classList.remove('show');
    render();
  });

  socket.on('room-count', ({ puzzleDate, count }) => {
    if (count > 0) {
      roomCounts.set(puzzleDate, count);
    } else {
      roomCounts.delete(puzzleDate);
    }
    const dayEl = document.querySelector(`.cal-day[data-date="${puzzleDate}"]`);
    if (dayEl) {
      let badge = dayEl.querySelector('.player-count-badge');
      if (count > 0) {
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'player-count-badge';
          dayEl.appendChild(badge);
        }
        badge.textContent = count;
      } else if (badge) {
        badge.remove();
      }
    }
  });

  socket.on('puzzle-progress', (summary) => {
    calendarData.set(summary.date, summary);
    const dayEl = document.querySelector(`.cal-day[data-date="${summary.date}"]`);
    if (dayEl && !dayEl.classList.contains('no-puzzle')) {
      dayEl.classList.toggle('complete', summary.isComplete);
      const canvas = dayEl.querySelector('canvas');
      if (canvas) drawThumbnail(canvas, summary);
    }
  });

  // Fire streak: server confirmation for local user
  socket.on('fire-update', (fireEvent) => {
    if (!PUZZLE) return;
    if (fireEvent.type === 'started') {
      const cellKeys = fireEvent.fireCells.map(c => `${c.row},${c.col}`);
      myFireMultiplier = fireEvent.fireMultiplier || 1.5;
      // Server is authoritative; sync up if needed
      if (!myFireActive) {
        startMyFire(cellKeys, Date.now() + fireEvent.remainingMs);
      }
    } else if (fireEvent.type === 'extended') {
      myFireExpiresAt = Date.now() + fireEvent.remainingMs;
      if (fireEvent.fireMultiplier) myFireMultiplier = fireEvent.fireMultiplier;
      // Sync fire cells from server (all user cells)
      myFireCells.clear();
      for (const c of fireEvent.fireCells) {
        myFireCells.add(`${c.row},${c.col}`);
      }
      applyFireCellEffects();
    } else if (fireEvent.type === 'broken') {
      if (myFireActive) breakMyFire();
    }
  });

  // Fire streak: remote user fire events (via cell-updated fireEvent field)
  // Handled inside cell-updated handler above

  // Fire streak: remote fire expired naturally
  socket.on('fire-expired', ({ socketId: remoteSocketId, userName: remoteName, color: remoteColor, fireCells }) => {
    if (!PUZZLE) return;
    const rs = remoteFireStates.get(remoteSocketId);
    if (rs) {
      for (const key of rs.fireCells) {
        const [r, c] = key.split(',').map(Number);
        if (cellEls[r]?.[c]) cellEls[r][c].classList.remove('on-fire');
      }
      remoteFireStates.delete(remoteSocketId);
    }
  });

  // â”€â”€â”€ Hint system events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  socket.on('hint-available', () => {
    if (!PUZZLE || solved) return;
    showHintBtn();
  });

  socket.on('hint-vote-update', ({ votes, total }) => {
    if (!PUZZLE) return;
    updateHintVoteText(votes, total);
    // Make sure button is visible
    const btn = document.getElementById('hint-btn');
    if (btn && !btn.classList.contains('show')) btn.classList.add('show');
  });

  socket.on('hint-reveal', ({ cells }) => {
    if (!PUZZLE) return;
    applyHintReveal(cells);
  });
}

function findColorForUser(userId) {
  for (const [, u] of remoteUsers) {
    if (u.userId === userId) return u.color;
  }
  return '#ccc';
}

function updateFillerColorsFromRoom() {
  // After getting room state, update filler colors for users we now know about
  const nameColorMap = new Map();
  nameColorMap.set(myName, myColor);
  for (const [, u] of remoteUsers) {
    nameColorMap.set(u.userName, u.color);
  }
  for (const [key, filler] of cellFillers) {
    const knownColor = nameColorMap.get(filler.userName);
    if (knownColor) {
      filler.color = knownColor;
      cellColors.set(key, knownColor);
    }
  }
}

function computeUserPoints() {
  if (!PUZZLE) return new Map();
  const points = new Map(); // userName â†’ { color, pts }

  function ensure(name, color) {
    if (!points.has(name)) points.set(name, { color: color || '#ccc', pts: 0 });
    const p = points.get(name);
    if (color && color !== '#ccc') p.color = color;
    return p;
  }

  // Start from persisted base points (includes all historical +1/-1 from letter placements)
  for (const [name, pts] of persistedPoints) {
    ensure(name, null).pts = pts;
  }

  // Apply filler colors (so we know each user's color for display)
  for (const [, filler] of cellFillers) {
    ensure(filler.userName, filler.color);
  }

  // Word bonuses (+5/+15) are now persisted server-side in the points total

  return points;
}

function renderPresenceBar() {
  presenceBarEl.innerHTML = '';

  const points = computeUserPoints();

  // Build list: current user + online remote users
  const allUsers = [{ name: myName, color: myColor, label: myName || 'You' }];
  const seenNames = new Set([myName]);
  for (const [, user] of remoteUsers) {
    if (!seenNames.has(user.userName)) {
      allUsers.push({ name: user.userName, color: user.color, label: user.userName });
      seenNames.add(user.userName);
    }
  }
  // Include offline users who have points (from persisted fillers)
  for (const [name, data] of points) {
    if (!seenNames.has(name)) {
      allUsers.push({ name, color: data.color, label: name });
      seenNames.add(name);
    }
  }

  if (allUsers.length <= 1 && !points.has(myName)) {
    presenceBarEl.style.display = 'none';
    return;
  }
  presenceBarEl.style.display = '';

  // Count filled squares per player
  const filledCounts = new Map();
  for (const [, filler] of cellFillers) {
    filledCounts.set(filler.userName, (filledCounts.get(filler.userName) || 0) + 1);
  }

  for (const u of allUsers) {
    const data = points.get(u.name);
    const pts = data ? data.pts : 0;
    const filled = filledCounts.get(u.name) || 0;
    const el = document.createElement('span');
    el.className = 'presence-user';
    const filledStr = filled > 0 ? ` <span class="presence-filled">${filled}</span>` : '';
    const ptsStr = pts !== 0 ? ` <span class="presence-pts">${pts > 0 ? '+' : ''}${pts}</span>` : '';
    el.innerHTML = `<span class="presence-dot" style="background:${u.color}"></span>${u.label}${filledStr}${ptsStr}`;
    if (u.name === myName) {
      el.style.cursor = 'pointer';
      el.addEventListener('click', () => showNameModal(true));
    }
    presenceBarEl.appendChild(el);
  }
}

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function isBlack(r, c) {
  return PUZZLE.grid[r]?.[c] === '.';
}

function inBounds(r, c) {
  return r >= 0 && r < ROWS && c >= 0 && c < COLS;
}

function getClueForCell(r, c, dir) {
  const clues = dir === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  for (let i = clues.length - 1; i >= 0; i--) {
    const cl = clues[i];
    if (dir === 'across') {
      if (cl.row === r && cl.col <= c && cl.col + getWordLen(cl, 'across') > c) return cl;
    } else {
      if (cl.col === c && cl.row <= r && cl.row + getWordLen(cl, 'down') > r) return cl;
    }
  }
  return null;
}

function getWordLen(clue, dir) {
  if (clue.answer) return clue.answer.length;
  let len = 0;
  if (dir === 'across') {
    for (let c = clue.col; c < COLS && !isBlack(clue.row, c); c++) len++;
  } else {
    for (let r = clue.row; r < ROWS && !isBlack(r, clue.col); r++) len++;
  }
  return len;
}

function getWordCells(clue, dir) {
  const cells = [];
  const len = getWordLen(clue, dir);
  for (let i = 0; i < len; i++) {
    if (dir === 'across') cells.push([clue.row, clue.col + i]);
    else cells.push([clue.row + i, clue.col]);
  }
  return cells;
}

// â”€â”€â”€ Build Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let cellEls = [];

function buildGrid() {
  gridScale = 1; gridTx = 0; gridTy = 0;
  gridEl.style.transform = '';
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;
  gridEl.style.gridTemplateRows = `repeat(${ROWS}, var(--cell-size))`;

  cellEls = [];
  for (let r = 0; r < ROWS; r++) {
    cellEls[r] = [];
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell' + (isBlack(r, c) ? ' black' : '');

      const num = PUZZLE.cellNumbers[r][c];
      if (num > 0) {
        const numSpan = document.createElement('span');
        numSpan.className = 'number';
        numSpan.textContent = num;
        cell.appendChild(numSpan);
      }

      if (!isBlack(r, c)) {
        const letterSpan = document.createElement('span');
        letterSpan.className = 'letter';
        cell.appendChild(letterSpan);

        // Circle overlay
        const key = `${r},${c}`;
        if (PUZZLE.circles.has(key)) {
          cell.classList.add('circled');
        }

        // Shade background
        const shadeColor = PUZZLE.shades.get(key);
        if (shadeColor) {
          cell.classList.add('shaded');
          cell.style.setProperty('--shade-color', shadeColor);
        }

        // Rebus cell thick outline
        if (PUZZLE.rebus[key]) {
          cell.classList.add('rebus-cell');
        }
      }

      cell.addEventListener('click', () => onCellClick(r, c));
      gridEl.appendChild(cell);
      cellEls[r][c] = cell;
    }
  }

  if (!IS_MOBILE) {
    const gridH = ROWS * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) + 4;
    cluePanelEl.style.maxHeight = gridH + 'px';
    for (const sec of cluePanelEl.querySelectorAll('.clue-section')) {
      sec.style.maxHeight = gridH + 'px';
    }
  } else {
    cluePanelEl.style.maxHeight = '300px';
  }
}

// â”€â”€â”€ Build Clue Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let clueItemEls = {};

function buildCluePanel() {
  cluePanelEl.innerHTML = '';
  clueItemEls = {};

  for (const dir of ['across', 'down']) {
    const section = document.createElement('div');
    section.className = 'clue-section';
    const h2 = document.createElement('h2');
    h2.textContent = dir.charAt(0).toUpperCase() + dir.slice(1);
    section.appendChild(h2);

    for (const clue of PUZZLE.clues[dir]) {
      const item = document.createElement('div');
      item.className = 'clue-item';

      const numSpan = document.createElement('span');
      numSpan.className = 'clue-num';
      numSpan.textContent = clue.n;
      item.appendChild(numSpan);

      const textSpan = document.createElement('span');
      textSpan.className = 'clue-text';
      textSpan.textContent = clue.clue;
      item.appendChild(textSpan);

      item.addEventListener('click', () => {
        direction = dir;
        selectedRow = clue.row;
        selectedCol = clue.col;
        render();
        focusGrid();
      });

      section.appendChild(item);
      clueItemEls[`${dir}-${clue.n}`] = item;
    }
    cluePanelEl.appendChild(section);
  }
}

// â”€â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  if (!PUZZLE) return;
  const currentClue = getClueForCell(selectedRow, selectedCol, direction);
  const wordCells = currentClue ? getWordCells(currentClue, direction) : [];
  const wordSet = new Set(wordCells.map(([r,c]) => `${r},${c}`));

  // Build remote user highlight maps
  const remoteCursorCells = new Map(); // "r,c" â†’ color (selected cell)
  const remoteWordCells = new Map();   // "r,c" â†’ color (word highlight)
  for (const [, user] of remoteUsers) {
    if (!PUZZLE) break;
    const rClue = getClueForCell(user.row, user.col, user.direction);
    if (rClue) {
      const rWordCells = getWordCells(rClue, user.direction);
      for (const [wr, wc] of rWordCells) {
        const key = `${wr},${wc}`;
        if (!remoteWordCells.has(key)) remoteWordCells.set(key, user.color);
      }
    }
    remoteCursorCells.set(`${user.row},${user.col}`, user.color);
  }

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const el = cellEls[r][c];
      if (isBlack(r, c)) continue;

      const key = `${r},${c}`;
      const isMyWord = wordSet.has(key);
      const isMyCell = r === selectedRow && c === selectedCol;

      el.classList.toggle('highlight-word', isMyWord);
      el.classList.toggle('highlight-cell', isMyCell);

      const letterEl = el.querySelector('.letter');
      if (letterEl) {
        // Show rebus buffer for the active cell in rebus mode
        const displayText = (rebusMode && isMyCell && rebusBuffer) ? rebusBuffer : userGrid[r][c];
        letterEl.textContent = displayText;
        // Shrink font for multi-letter content
        letterEl.classList.toggle('rebus-text', displayText.length > 1);
      }

      // Rebus mode indicator on active cell
      el.classList.toggle('rebus-active', rebusMode && isMyCell);

      el.classList.toggle('hint-cell', hintCells.has(key));
      const wcColor = completedWordCells.get(key);
      el.classList.toggle('word-complete', !!wcColor && !hintCells.has(key));
      if (wcColor && !hintCells.has(key)) {
        el.style.setProperty('--wc-color', wcColor);
      }
      el.classList.toggle('checked', checkedCells[r][c]);
      if (autoCheck && userGrid[r][c] && !checkedCells[r][c]) {
        el.classList.toggle('error', userGrid[r][c] !== getCorrectAnswer(r, c));
      } else {
        el.classList.remove('error');
      }

      // Background color priority: hint > my cell/word > completed word gradient > remote cursor > remote word > none
      const isHint = hintCells.has(key);
      const remoteCursorColor = remoteCursorCells.get(key);
      const remoteWordColor = remoteWordCells.get(key);

      if (isHint) {
        // Hint cells: clear inline bg so CSS gradient takes full effect
        el.style.backgroundColor = '';
        el.style.background = '';
      } else if (isMyCell || isMyWord) {
        // Let CSS classes (highlight-cell / highlight-word) handle it
        el.style.backgroundColor = '';
        el.style.background = '';
      } else if (wcColor) {
        // Completed word: gradient fill in player color
        const hex = wcColor.replace('#', '');
        const rr = parseInt(hex.substring(0, 2), 16);
        const gg = parseInt(hex.substring(2, 4), 16);
        const bb = parseInt(hex.substring(4, 6), 16);
        el.style.background = `linear-gradient(135deg, rgba(${rr},${gg},${bb},0.15), rgba(${rr},${gg},${bb},0.35))`;
      } else if (remoteCursorColor) {
        el.style.background = '';
        el.style.backgroundColor = '#FFA500';
      } else if (remoteWordColor) {
        const hex = remoteWordColor.replace('#', '');
        const rr = parseInt(hex.substring(0, 2), 16);
        const gg = parseInt(hex.substring(2, 4), 16);
        const bb = parseInt(hex.substring(4, 6), 16);
        el.style.background = '';
        el.style.backgroundColor = `rgba(${rr},${gg},${bb},0.25)`;
      } else {
        el.style.backgroundColor = '';
        el.style.background = '';
      }

      // Cell filler color: colored inset box-shadow showing who typed the letter
      const fillerColor = cellColors.get(key);
      if (fillerColor && userGrid[r][c]) {
        el.style.boxShadow = `inset 0 0 0 2px ${fillerColor}`;
      } else {
        el.style.boxShadow = '';
      }

      // Fire cell effect
      const isOnFire = myFireCells.has(key) || [...remoteFireStates.values()].some(s => s.fireCells.has(key));
      el.classList.toggle('on-fire', isOnFire);
    }
  }

  const clueBarTextEl = clueBarEl.querySelector('#clue-bar-text');
  if (currentClue) {
    const dirLabel = direction === 'across' ? 'A' : 'D';
    clueBarTextEl.textContent = `${currentClue.n}${dirLabel}: ${currentClue.clue}`;
  } else {
    clueBarTextEl.innerHTML = '&nbsp;';
  }

  for (const k in clueItemEls) {
    clueItemEls[k].classList.remove('active');
  }
  if (currentClue) {
    const k = `${direction}-${currentClue.n}`;
    if (clueItemEls[k]) {
      clueItemEls[k].classList.add('active');
      // Scroll active clue into view, accounting for sticky header
      const el = clueItemEls[k];
      const section = el.closest('.clue-section');
      if (section) {
        const stickyH = section.querySelector('h2');
        const headerHeight = stickyH ? stickyH.offsetHeight : 0;
        const sectionRect = section.getBoundingClientRect();
        const elRect = el.getBoundingClientRect();
        const visibleTop = sectionRect.top + headerHeight;
        if (elRect.top < visibleTop) {
          section.scrollTop += elRect.top - visibleTop;
        } else if (elRect.bottom > sectionRect.bottom) {
          section.scrollTop += elRect.bottom - sectionRect.bottom;
        }
      }
    }
  }

  // Mark solved clues
  for (const dir of ['across', 'down']) {
    for (const clue of PUZZLE.clues[dir]) {
      const k = `${dir}-${clue.n}`;
      const el = clueItemEls[k];
      if (!el) continue;
      const wCells = getWordCells(clue, dir);
      const isSolved = wCells.length > 0 && wCells.every(([wr, wc]) =>
        userGrid[wr][wc] && userGrid[wr][wc] === getCorrectAnswer(wr, wc)
      );
      el.classList.toggle('solved', isSolved);
    }
  }

  // Update presence bar with live percentages
  renderPresenceBar();

  broadcastCursor();
}

// â”€â”€â”€ Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function onCellClick(r, c) {
  if (isBlack(r, c)) return;
  // Commit rebus buffer when clicking a different cell
  if (rebusMode && rebusBuffer && (r !== selectedRow || c !== selectedCol)) {
    commitRebus();
  }
  if (r === selectedRow && c === selectedCol) {
    direction = direction === 'across' ? 'down' : 'across';
    if (!getClueForCell(r, c, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
  } else {
    selectedRow = r;
    selectedCol = c;
    if (!getClueForCell(r, c, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
  }
  render();
  focusGrid();
}

function advanceCursor(skipFilled = false) {
  if (direction === 'across') {
    let nc = selectedCol + 1;
    while (nc < COLS && (isBlack(selectedRow, nc) || (skipFilled && userGrid[selectedRow][nc]))) nc++;
    if (nc < COLS) selectedCol = nc;
  } else {
    let nr = selectedRow + 1;
    while (nr < ROWS && (isBlack(nr, selectedCol) || (skipFilled && userGrid[nr][selectedCol]))) nr++;
    if (nr < ROWS) selectedRow = nr;
  }
}

function retreatCursor() {
  if (direction === 'across') {
    let nc = selectedCol - 1;
    if (nc >= 0 && !isBlack(selectedRow, nc)) selectedCol = nc;
  } else {
    let nr = selectedRow - 1;
    if (nr >= 0 && !isBlack(nr, selectedCol)) selectedRow = nr;
  }
}

function isWordSolved(clue, dir) {
  const cells = getWordCells(clue, dir);
  return cells.every(([r, c]) => userGrid[r][c] && userGrid[r][c] === getCorrectAnswer(r, c));
}

function firstUnsolvedCell(clue, dir) {
  const cells = getWordCells(clue, dir);
  for (const [r, c] of cells) {
    if (!userGrid[r][c] || userGrid[r][c] !== getCorrectAnswer(r, c)) return [r, c];
  }
  return [clue.row, clue.col]; // fallback to start
}

function moveToNextWord(forward) {
  const dirs = [direction, direction === 'across' ? 'down' : 'across'];
  const currentClue = getClueForCell(selectedRow, selectedCol, direction);
  if (!currentClue) return;

  // Build ordered list: remaining clues in current direction, then all in other direction
  const curClues = dirs[0] === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  const otherClues = dirs[1] === 'across' ? PUZZLE.clues.across : PUZZLE.clues.down;
  const curIdx = curClues.findIndex(c => c.n === currentClue.n);

  // Candidates: rest of current list, then full other list, then start of current list (wrap)
  const candidates = [];
  if (forward) {
    for (let i = curIdx + 1; i < curClues.length; i++) candidates.push({ clue: curClues[i], dir: dirs[0] });
    for (let i = 0; i < otherClues.length; i++) candidates.push({ clue: otherClues[i], dir: dirs[1] });
    for (let i = 0; i <= curIdx; i++) candidates.push({ clue: curClues[i], dir: dirs[0] });
  } else {
    for (let i = curIdx - 1; i >= 0; i--) candidates.push({ clue: curClues[i], dir: dirs[0] });
    for (let i = otherClues.length - 1; i >= 0; i--) candidates.push({ clue: otherClues[i], dir: dirs[1] });
    for (let i = curClues.length - 1; i >= curIdx; i--) candidates.push({ clue: curClues[i], dir: dirs[0] });
  }

  // Find first unsolved word
  for (const cand of candidates) {
    if (!isWordSolved(cand.clue, cand.dir)) {
      direction = cand.dir;
      const [r, c] = firstUnsolvedCell(cand.clue, cand.dir);
      selectedRow = r;
      selectedCol = c;
      render();
      return;
    }
  }

  // All solved â€” just move to next word normally
  const nextIdx = forward ? (curIdx + 1) % curClues.length : (curIdx - 1 + curClues.length) % curClues.length;
  selectedRow = curClues[nextIdx].row;
  selectedCol = curClues[nextIdx].col;
  render();
}

function moveArrow(dr, dc) {
  const newDir = dc !== 0 ? 'across' : 'down';

  if (newDir !== direction) {
    if (getClueForCell(selectedRow, selectedCol, newDir)) {
      direction = newDir;
      return;
    }
  }

  let r = selectedRow + dr;
  let c = selectedCol + dc;
  while (inBounds(r, c) && isBlack(r, c)) { r += dr; c += dc; }
  if (inBounds(r, c)) {
    selectedRow = r;
    selectedCol = c;
    direction = newDir;
  }
}

function computeAccuracy() {
  // Return guess-based accuracy: total guesses and incorrect guesses per user
  const stats = new Map(); // userName â†’ { correct, total }
  for (const [name, gs] of guessStats) {
    stats.set(name, { correct: gs.total - gs.incorrect, total: gs.total });
  }
  return stats;
}

function showLeaderboard() {
  const points = computeUserPoints();
  const accuracy = computeAccuracy();
  const titleEl = document.getElementById('congrats-title');
  const msgEl = document.getElementById('congrats-msg');
  const lbEl = document.getElementById('leaderboard');

  // Count filled squares per player
  const filledCells = new Map();
  for (const [, filler] of cellFillers) {
    filledCells.set(filler.userName, (filledCells.get(filler.userName) || 0) + 1);
  }

  // Build sorted list
  const players = [];
  for (const [name, data] of points) {
    const acc = accuracy.get(name) || { correct: 0, total: 0 };
    const pct = acc.total > 0 ? Math.round((acc.correct / acc.total) * 100) : 0;
    const filled = filledCells.get(name) || 0;
    players.push({ name, color: data.color, pts: data.pts, pct, filled });
  }
  players.sort((a, b) => b.pts - a.pts);

  if (players.length > 0) {
    titleEl.textContent = `${players[0].name} wins!`;
    msgEl.textContent = 'Puzzle complete! Final standings:';
  } else {
    titleEl.textContent = 'Congratulations!';
    msgEl.textContent = 'You solved the crossword!';
  }

  lbEl.innerHTML = '';
  players.forEach((p, i) => {
    const row = document.createElement('div');
    row.className = 'leaderboard-row';
    row.innerHTML = `
      <span class="leaderboard-rank">${i + 1}.</span>
      <span class="leaderboard-dot" style="background:${p.color}"></span>
      <span class="leaderboard-name">${p.name}</span>
      <span class="leaderboard-stats">${p.filled} sq</span>
      <span class="leaderboard-stats">${p.pct}% acc</span>
      <span class="leaderboard-pts">${p.pts > 0 ? '+' : ''}${p.pts} pts</span>
    `;
    lbEl.appendChild(row);
  });
}

function checkCompletion() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (!isBlack(r, c) && userGrid[r][c] !== getCorrectAnswer(r, c)) return;
    }
  }
  if (!solved) {
    // Award 250 point bonus to whoever filled the last square
    const lastFiller = cellFillers.get(`${selectedRow},${selectedCol}`);
    if (lastFiller) {
      const bonus = 250;
      persistedPoints.set(lastFiller.userName, (persistedPoints.get(lastFiller.userName) || 0) + bonus);
      showPointFloat(selectedRow, selectedCol, bonus, 'combo', false);
    }
    sfxVictory();
  }
  solved = true;
  showLeaderboard();
  congratsEl.classList.add('show');
}

const mobileInput = document.getElementById('mobile-input');
function focusGrid() {
  if (IS_MOBILE) {
    mobileInput.focus();
  } else {
    gridEl.focus();
  }
}

// â”€â”€â”€ Mobile input handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
mobileInput.addEventListener('input', (e) => {
  if (!PUZZLE || solved) return;
  const val = mobileInput.value;
  mobileInput.value = '';
  if (!val) return;
  const char = val.slice(-1);
  if (/^[a-zA-Z]$/.test(char)) {
    if (rebusMode) {
      rebusBuffer += char.toUpperCase();
      render();
      return;
    }
    if (!checkedCells[selectedRow][selectedCol]) {
      const letter = char.toUpperCase();
      userGrid[selectedRow][selectedCol] = letter;
      sendCellUpdate(selectedRow, selectedCol, letter);
      if (autoCheck && letter === getCorrectAnswer(selectedRow, selectedCol)) {
        checkedCells[selectedRow][selectedCol] = true;
      }
    }
    render();
    advanceCursor(true);
    render();
    checkCompletion();
  }
});

mobileInput.addEventListener('keydown', (e) => {
  if (!PUZZLE || solved) return;
  if (e.key === 'Backspace') {
    e.preventDefault();
    if (rebusMode) { rebusBuffer = rebusBuffer.slice(0, -1); render(); return; }
    if (checkedCells[selectedRow][selectedCol]) {
      retreatCursor();
    } else if (userGrid[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    } else {
      retreatCursor();
      if (!checkedCells[selectedRow][selectedCol]) {
        userGrid[selectedRow][selectedCol] = '';
        sendCellUpdate(selectedRow, selectedCol, '');
      }
    }
    render();
  }
});

// â”€â”€â”€ Rebus mode helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function commitRebus() {
  const hadContent = !!rebusBuffer;
  if (rebusBuffer && !checkedCells[selectedRow][selectedCol]) {
    userGrid[selectedRow][selectedCol] = rebusBuffer;
    sendCellUpdate(selectedRow, selectedCol, rebusBuffer);
    if (autoCheck && rebusBuffer === getCorrectAnswer(selectedRow, selectedCol)) {
      checkedCells[selectedRow][selectedCol] = true;
    }
  }
  rebusBuffer = '';
  rebusMode = false;
  btnRebus.classList.remove('active');
  render();
  if (hadContent) {
    advanceCursor(true);
    render();
    checkCompletion();
  }
}

function toggleRebus() {
  if (rebusMode) {
    if (rebusBuffer) {
      commitRebus();
    } else {
      rebusMode = false;
      rebusBuffer = '';
      btnRebus.classList.remove('active');
      render();
    }
  } else {
    rebusMode = true;
    rebusBuffer = '';
    btnRebus.classList.add('active');
    render();
  }
}

// â”€â”€â”€ Keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
gridEl.addEventListener('keydown', (e) => {
  if (!PUZZLE || solved) return;
  const key = e.key;

  // In rebus mode, handle special keys
  if (rebusMode) {
    if (key === 'Enter' || key === 'Escape') {
      e.preventDefault();
      if (key === 'Enter' && rebusBuffer) {
        commitRebus();
      } else {
        rebusMode = false;
        rebusBuffer = '';
        btnRebus.classList.remove('active');
        render();
      }
      return;
    }
    if (key === 'Backspace') {
      e.preventDefault();
      rebusBuffer = rebusBuffer.slice(0, -1);
      render();
      return;
    }
    if (/^[a-zA-Z]$/.test(key)) {
      e.preventDefault();
      rebusBuffer += key.toUpperCase();
      render();
      return;
    }
    // Any other key (arrows, tab, space) commits the rebus buffer
    if (rebusBuffer) commitRebus();
    else { rebusMode = false; rebusBuffer = ''; btnRebus.classList.remove('active'); render(); }
    // Fall through to handle the key normally
  }

  if (key === 'ArrowLeft')       { e.preventDefault(); moveArrow(0, -1); render(); }
  else if (key === 'ArrowRight') { e.preventDefault(); moveArrow(0, 1); render(); }
  else if (key === 'ArrowUp')    { e.preventDefault(); moveArrow(-1, 0); render(); }
  else if (key === 'ArrowDown')  { e.preventDefault(); moveArrow(1, 0); render(); }
  else if (key === 'Tab') {
    e.preventDefault();
    moveToNextWord(!e.shiftKey);
  }
  else if (key === ' ') {
    e.preventDefault();
    direction = direction === 'across' ? 'down' : 'across';
    if (!getClueForCell(selectedRow, selectedCol, direction)) {
      direction = direction === 'across' ? 'down' : 'across';
    }
    render();
  }
  else if (key === 'Insert') {
    e.preventDefault();
    toggleRebus();
  }
  else if (key === 'Backspace') {
    e.preventDefault();
    if (checkedCells[selectedRow][selectedCol]) {
      retreatCursor();
    } else if (userGrid[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    } else {
      retreatCursor();
      if (!checkedCells[selectedRow][selectedCol]) {
        userGrid[selectedRow][selectedCol] = '';
        sendCellUpdate(selectedRow, selectedCol, '');
      }
    }
    render();
  }
  else if (key === 'Delete') {
    e.preventDefault();
    if (!checkedCells[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    }
    render();
  }
  else if (/^[a-zA-Z]$/.test(key)) {
    e.preventDefault();
    if (!checkedCells[selectedRow][selectedCol]) {
      const letter = key.toUpperCase();
      userGrid[selectedRow][selectedCol] = letter;
      sendCellUpdate(selectedRow, selectedCol, letter);
      if (autoCheck && letter === getCorrectAnswer(selectedRow, selectedCol)) {
        checkedCells[selectedRow][selectedCol] = true;
      }
    }
    render();
    advanceCursor(true);
    render();
    checkCompletion();
  }
});

// â”€â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
btnBack.addEventListener('click', () => showCalendar());

document.getElementById('hint-btn').addEventListener('click', voteForHint);

btnClear.addEventListener('click', () => {
  if (!PUZZLE || !confirm('Clear all entered letters?')) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      userGrid[r][c] = '';
      checkedCells[r][c] = false;
    }
  cellColors.clear();
  cellFillers.clear();
  persistedPoints.clear();
  guessStats.clear();
  solved = false;
  congratsEl.classList.remove('show');
  if (currentDate && socket) {
    socket.emit('clear-puzzle', { puzzleDate: currentDate });
  }
  render();
});

btnReveal.addEventListener('click', () => {
  if (!PUZZLE || !confirm('Reveal the entire puzzle?')) return;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (!isBlack(r, c)) {
        const answer = getCorrectAnswer(r, c);
        userGrid[r][c] = answer;
        sendCellUpdate(r, c, answer);
      }
  render();
  checkCompletion();
});

btnRebus.addEventListener('click', () => {
  if (!PUZZLE || solved) return;
  toggleRebus();
  focusGrid();
});

// â”€â”€â”€ Mobile keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initMobileKeyboard() {
  const kb = document.getElementById('mobile-keyboard');
  const rows = [
    ['Q','W','E','R','T','Y','U','I','O','P'],
    ['A','S','D','F','G','H','J','K','L'],
    ['MORE','Z','X','C','V','B','N','M','BACK'],
  ];

  rows.forEach(letters => {
    const rowEl = document.createElement('div');
    rowEl.className = 'kb-row';
    letters.forEach(l => {
      const btn = document.createElement('button');
      btn.className = 'kb-key';
      if (l === 'MORE') {
        btn.classList.add('kb-more');
        btn.textContent = 'Rebus';
      } else if (l === 'BACK') {
        btn.classList.add('kb-backspace');
        btn.textContent = '\u232B';
      } else {
        btn.textContent = l;
      }
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (!PUZZLE || solved) return;
        if (l === 'MORE') { toggleRebus(); return; }
        if (l === 'BACK') {
          if (rebusMode) { rebusBuffer = rebusBuffer.slice(0, -1); render(); return; }
          handleBackspace();
        } else {
          handleLetterInput(l);
        }
      });
      rowEl.appendChild(btn);
    });
    kb.appendChild(rowEl);
  });
}

function handleLetterInput(letter) {
  if (rebusMode) {
    rebusBuffer += letter;
    render();
    return;
  }
  if (!checkedCells[selectedRow][selectedCol]) {
    userGrid[selectedRow][selectedCol] = letter;
    sendCellUpdate(selectedRow, selectedCol, letter);
    if (autoCheck && letter === getCorrectAnswer(selectedRow, selectedCol)) {
      checkedCells[selectedRow][selectedCol] = true;
    }
  }
  render();
  advanceCursor(true);
  render();
  checkCompletion();
}

function handleBackspace() {
  if (checkedCells[selectedRow][selectedCol]) {
    retreatCursor();
  } else if (userGrid[selectedRow][selectedCol]) {
    userGrid[selectedRow][selectedCol] = '';
    sendCellUpdate(selectedRow, selectedCol, '');
  } else {
    retreatCursor();
    if (!checkedCells[selectedRow][selectedCol]) {
      userGrid[selectedRow][selectedCol] = '';
      sendCellUpdate(selectedRow, selectedCol, '');
    }
  }
  render();
}

// Override focusGrid to skip hidden input on mobile
const origFocusGrid = focusGrid;
focusGrid = function() {
  if (IS_MOBILE) {
    // Don't focus the hidden input â€” custom keyboard handles input
    gridEl.focus();
  } else {
    origFocusGrid();
  }
};

// On mobile, prevent the hidden input from showing the system keyboard
if (IS_MOBILE) {
  mobileInput.setAttribute('inputmode', 'none');
  mobileInput.setAttribute('readonly', 'true');
}

initMobileKeyboard();

// â”€â”€â”€ Mobile grid pinch-to-zoom + pan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (IS_MOBILE) {
  const gc = document.querySelector('.grid-container');
  let pinchInitDist = 0, pinchInitScale = 1;
  let pinchInitCenter = {x: 0, y: 0};
  let pinchInitTx = 0, pinchInitTy = 0;
  let isPinching = false;
  let panStart = null, panStartTx = 0, panStartTy = 0, didPan = false;

  function applyGridTransform() {
    gridEl.style.transformOrigin = '0 0';
    gridEl.style.transform = `translate(${gridTx}px,${gridTy}px) scale(${gridScale})`;
  }

  function clampGridPos() {
    const cr = gc.getBoundingClientRect();
    const gw = gridEl.offsetWidth * gridScale;
    const gh = gridEl.offsetHeight * gridScale;
    if (gw <= cr.width) { gridTx = (cr.width - gw) / 2; }
    else { gridTx = Math.min(0, Math.max(cr.width - gw, gridTx)); }
    if (gh <= cr.height) { gridTy = (cr.height - gh) / 2; }
    else { gridTy = Math.min(0, Math.max(cr.height - gh, gridTy)); }
  }

  function pDist(t) {
    const dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function pCenter(t) {
    return { x: (t[0].clientX + t[1].clientX) / 2, y: (t[0].clientY + t[1].clientY) / 2 };
  }

  gc.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      e.preventDefault();
      isPinching = true;
      // Initialize transform from flex-centered position if needed
      if (gridScale === 1 && gridTx === 0 && gridTy === 0) {
        const gr = gridEl.getBoundingClientRect();
        const cr = gc.getBoundingClientRect();
        gridTx = gr.left - cr.left;
        gridTy = gr.top - cr.top;
        applyGridTransform();
      }
      pinchInitDist = pDist(e.touches);
      pinchInitScale = gridScale;
      pinchInitCenter = pCenter(e.touches);
      pinchInitTx = gridTx;
      pinchInitTy = gridTy;
      panStart = null;
    } else if (e.touches.length === 1 && gridScale > 1) {
      panStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      panStartTx = gridTx;
      panStartTy = gridTy;
      didPan = false;
    }
  }, { passive: false });

  gc.addEventListener('touchmove', e => {
    if (isPinching && e.touches.length === 2) {
      e.preventDefault();
      const nd = pDist(e.touches);
      const nc = pCenter(e.touches);
      const newScale = Math.max(1, Math.min(4, pinchInitScale * (nd / pinchInitDist)));
      // Zoom toward pinch center
      const rect = gc.getBoundingClientRect();
      const cx = pinchInitCenter.x - rect.left;
      const cy = pinchInitCenter.y - rect.top;
      const gx = (cx - pinchInitTx) / pinchInitScale;
      const gy = (cy - pinchInitTy) / pinchInitScale;
      gridTx = (nc.x - rect.left) - gx * newScale;
      gridTy = (nc.y - rect.top) - gy * newScale;
      gridScale = newScale;
      clampGridPos();
      applyGridTransform();
    } else if (e.touches.length === 1 && panStart && gridScale > 1) {
      const dx = e.touches[0].clientX - panStart.x;
      const dy = e.touches[0].clientY - panStart.y;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) didPan = true;
      if (didPan) {
        e.preventDefault();
        gridTx = panStartTx + dx;
        gridTy = panStartTy + dy;
        clampGridPos();
        applyGridTransform();
      }
    }
  }, { passive: false });

  gc.addEventListener('touchend', e => {
    if (e.touches.length < 2) {
      isPinching = false;
      if (gridScale < 1.05) {
        gridScale = 1; gridTx = 0; gridTy = 0;
        gridEl.style.transform = '';
      }
    }
    if (e.touches.length === 0) panStart = null;
  });

  // Suppress cell clicks after panning
  gc.addEventListener('click', e => {
    if (didPan) { e.stopPropagation(); e.preventDefault(); didPan = false; }
  }, true);

  // Prevent overscroll/bounce everywhere except grid container
  puzzleView.addEventListener('touchmove', e => {
    if (!e.target.closest('.grid-container')) e.preventDefault();
  }, { passive: false });
}

// â”€â”€â”€ Clue bar navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('clue-prev').addEventListener('click', () => {
  if (!PUZZLE) return;
  moveToNextWord(false);
  render();
  focusGrid();
});
document.getElementById('clue-next').addEventListener('click', () => {
  if (!PUZZLE) return;
  moveToNextWord(true);
  render();
  focusGrid();
});

// â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startApp() {
  initCalendarNav();

  // Check URL path for a puzzle date (e.g. /2025-02-15)
  const urlPath = window.location.pathname.slice(1); // strip leading /
  if (/^\d{4}-\d{2}-\d{2}$/.test(urlPath)) {
    showPuzzle(urlPath, false); // don't push state, we're already at this URL
    history.replaceState({ view: 'puzzle', date: urlPath }, '', `/${urlPath}`);
  } else {
    const savedPuzzle = localStorage.getItem('crossword-current-puzzle');
    if (savedPuzzle) {
      showPuzzle(savedPuzzle);
    } else {
      history.replaceState({ view: 'calendar' }, '', '/');
      fetchAndRenderCalendar();
    }
  }

  // Handle browser back/forward
  window.addEventListener('popstate', (e) => {
    if (e.state?.view === 'puzzle' && e.state.date) {
      showPuzzle(e.state.date, false);
    } else {
      showCalendar(false);
    }
  });
}

// Begin: check identity first, then connect socket, then start app
initIdentity();
</script>
</body>
</html>
